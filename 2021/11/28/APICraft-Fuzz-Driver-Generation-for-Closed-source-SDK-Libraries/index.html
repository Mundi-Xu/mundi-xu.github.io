<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon_io/apple-touch-icon.png"><link rel="icon" href="/img/favicon_io/favicon.ico"><link rel="canonical" href="https://mundi-xu.github.io/2021/11/28/APICraft-Fuzz-Driver-Generation-for-Closed-source-SDK-Libraries/"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="煊宇"><meta name="keywords" content="LLM Security"><meta property="article:published_time" content="2021-11-28T06:05:31.000Z"><meta property="article:modified_time" content="2022-11-28T06:05:31.000Z"><meta property="article:section" content="Fuzzing"><meta property="article:tag" content="Fuzzing"><meta property="article:tag" content="Program Analysis"><meta property="article:tag" content="Fuzz Driver"><meta name="google-site-verification" content="8weHOmi2lqvnOxDE30WJFT51umo63nyCgfm8dXHNT5g"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><link rel="dns-prefetch" href="//at.alicdn.com"><link rel="dns-prefetch" href="//cdnjs.cloudflare.com"><link rel="dns-prefetch" href="//raw.githubusercontent.com"><link rel="dns-prefetch" href="//busuanzi.ibruce.info"><link rel="preconnect" href="https://at.alicdn.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="preconnect" href="https://busuanzi.ibruce.info" crossorigin><link rel="dns-prefetch" href="//www.googletagmanager.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/LXGWWenKaiScreen-Regular.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css" as="style" onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"></noscript><link rel="preload" href="/css/main.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/events.js" as="script"><link rel="preload" href="/js/plugins.js" as="script"><link rel="preload" href="/js/boot.js" as="script"><link rel="preload" href="/js/img-lazyload.js" as="script"><meta name="description" content="介绍APICraft系统，一种利用动态追踪和多目标遗传算法，自动化生成高质量Fuzz Driver的方法，旨在显著提升对闭源SDK的Fuzzing覆盖率和漏洞发现能力。"><meta property="og:type" content="article"><meta property="og:title" content="APICraft：Fuzz Driver Generation for Closed-source SDK Libraries"><meta property="og:url" content="https://mundi-xu.github.io/2021/11/28/APICraft-Fuzz-Driver-Generation-for-Closed-source-SDK-Libraries/index.html"><meta property="og:site_name" content="Hanyin&#39;s Space"><meta property="og:description" content="介绍APICraft系统，一种利用动态追踪和多目标遗传算法，自动化生成高质量Fuzz Driver的方法，旨在显著提升对闭源SDK的Fuzzing覆盖率和漏洞发现能力。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/01.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/02.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/03.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/04.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/05.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/06.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/7.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/8.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/9.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/10.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/11.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/12.png"><meta property="article:published_time" content="2021-11-28T06:05:31.000Z"><meta property="article:modified_time" content="2022-11-28T06:05:31.000Z"><meta property="article:author" content="煊宇"><meta property="article:tag" content="Fuzzing"><meta property="article:tag" content="Program Analysis"><meta property="article:tag" content="Fuzz Driver"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/01.png"><meta name="format-detection" content="telephone=no"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hanyin&#39;s Space"><meta name="referrer" content="no-referrer-when-downgrade"><meta name="renderer" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link rel="apple-touch-icon" sizes="180x180" href="/img/favicon_io/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon_io/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon_io/favicon-16x16.png"><link rel="manifest" href="/img/favicon_io/site.webmanifest"><script type="application/ld+json">{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "APICraft：Fuzz Driver Generation for Closed-source SDK Libraries",
    "author": {
      "@type": "Person",
      "name": "煊宇"
    },
    "datePublished": "2021-11-28T06:05:31.000Z",
    
    "dateModified": "2022-11-28T06:05:31.000Z",
    
    "description": "介绍APICraft系统，一种利用动态追踪和多目标遗传算法，自动化生成高质量Fuzz Driver的方法，旨在显著提升对闭源SDK的Fuzzing覆盖率和漏洞发现能力。",
    
    "publisher": {
      "@type": "Organization",
      "name": "Hanyin&#39;s Space",
      
      "logo": {
        "@type": "ImageObject",
        "url": "/img/favicon_io/favicon.ico"
      }
      
    },
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://mundi-xu.github.io/2021/11/28/APICraft-Fuzz-Driver-Generation-for-Closed-source-SDK-Libraries/index.html"
    },
    
    "keywords": "Fuzzing,Program Analysis,Fuzz Driver",
    
    
    "articleBody": "背景 在fuzzing过程中，安全研究员需要构建好⼀个应⽤程序⽤来接收fuzzer提供的fuzz input，这个应⽤程序我们称之为fuzz driver。过往的fuzzing相关研究⼤多针对于fuzzing引擎本身的优化提升，包括种⼦变异策略以及调度算法的优化，增加多维度的反馈，以及提升fuzzer速度等，这些研究已经将fuzzing研究变为红海，极其“内卷”。 而我们关注到，如何⾃动化地构建⼀个⾼质量的fuzz driver其实是⼀个同样关键的问题。直观来看，如果⼀个fuzz driver能够调⽤更多SDK提供的API，有更丰富的程序⾏为，那它在fuzzing过程中必然会有更⾼的覆盖率，从⽽更容易触发漏洞。因此如何⽣成⾼质量的fuzz driver是个值得深究的研究问题。 这篇⽂章主要解决了如何针对闭源SDK⾃动化⽣成⾼质量的fuzz driver问题。 1.1 实例   图 1：基于 CoreText库的两个 fuzz driver  图1是⼀个构建fuzz driver的例⼦，以macOS CoreText库为例，图1有两个fuzz drivers，分别是Consumer 1以"
    
  }</script><title>APICraft：Fuzz Driver Generation for Closed-source SDK Libraries - Hanyin&#39;s Space</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.2/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hint.css/3.0.0/hint.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"mundi-xu.github.io",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:3},web_analytics:{enable:!0,follow_dnt:!1,google:{measurement_id:"G-3847WCVNF2"}},search_path:"/local-search.json",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-3847WCVNF2",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","G-3847WCVNF2")})</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Hanyin's Space" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Hanyin&#39;s Space</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>Home</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>Archives</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>Categories</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>Tags</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>About</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>Links</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" rel="external nofollow noreferrer" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" rel="external nofollow noreferrer" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="APICraft：Fuzz Driver Generation for Closed-source SDK Libraries"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-11-28 14:05" pubdate>November 28, 2021 pm</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 7.9k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 66 mins </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> views</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Fuzzing" id="heading-b3223cbcfca5c067cae863e62b136167" role="tab" data-toggle="collapse" href="#collapse-b3223cbcfca5c067cae863e62b136167" aria-expanded="true">Fuzzing <span class="list-group-count">(4)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-b3223cbcfca5c067cae863e62b136167" role="tabpanel" aria-labelledby="heading-b3223cbcfca5c067cae863e62b136167"><div class="category-post-list"><a href="/2021/11/28/APICraft-Fuzz-Driver-Generation-for-Closed-source-SDK-Libraries/" title="APICraft：Fuzz Driver Generation for Closed-source SDK Libraries" class="list-group-item list-group-item-action active"><span class="category-post">APICraft：Fuzz Driver Generation for Closed-source SDK Libraries</span> </a><a href="/2021/07/03/Use-AFL-fuzz-pdfium/" title="利用AFL fuzz PDFium" class="list-group-item list-group-item-action"><span class="category-post">利用AFL fuzz PDFium</span> </a><a href="/2021/03/12/Start-Fuzzing-and-crashes-analysis/" title="AFL++学习日志（一）开始Fuzz与crashes分析" class="list-group-item list-group-item-action"><span class="category-post">AFL++学习日志（一）开始Fuzz与crashes分析</span> </a><a href="/2021/01/09/Installation-and-testing-of-AFL-under-WSL2/" title="WSL2下AFL的安装与测试" class="list-group-item list-group-item-action"><span class="category-post">WSL2下AFL的安装与测试</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">APICraft：Fuzz Driver Generation for Closed-source SDK Libraries</h1><p id="updated-time" class="note note-primary" style="display:none">Last updated on 2022-11-28T14:05:31+08:00</p><div class="markdown-body"><h1 id="背景">背景</h1><p>在fuzzing过程中，安全研究员需要构建好⼀个应⽤程序⽤来接收fuzzer提供的fuzz input，这个应⽤程序我们称之为fuzz driver。过往的fuzzing相关研究⼤多针对于fuzzing引擎本身的优化提升，包括种⼦变异策略以及调度算法的优化，增加多维度的反馈，以及提升fuzzer速度等，这些研究已经将fuzzing研究变为红海，极其“内卷”。</p><p>而我们关注到，如何⾃动化地构建⼀个⾼质量的fuzz driver其实是⼀个同样关键的问题。直观来看，如果⼀个fuzz driver能够调⽤更多SDK提供的API，有更丰富的程序⾏为，那它在fuzzing过程中必然会有更⾼的覆盖率，从⽽更容易触发漏洞。因此如何⽣成⾼质量的fuzz driver是个值得深究的研究问题。</p><p>这篇⽂章主要解决了如何针对闭源SDK⾃动化⽣成⾼质量的fuzz driver问题。</p><h1 id="实例"><strong>1.1 实例</strong></h1><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/01.png" alt="图 1：基于 CoreText库的两个 fuzz driver"><figcaption aria-hidden="true">图 1：基于 CoreText库的两个 fuzz driver</figcaption></figure><p>图1是⼀个构建fuzz driver的例⼦，以macOS CoreText库为例，图1有两个fuzz drivers，分别是Consumer 1以及Consumer 2，将具体API简化，以伪代码形式来表现（<strong>下面的序号标识了每个API调⽤，与图1相对应</strong>）：</p><ol type="1"><li>Consumer 1调用ProviderCreateWithData API创建了⼀个DataProvider对象prov；</li><li>基于prov对象创建了Font对象font；</li><li>最后计算出font对象的LeadingSpace的double值。</li><li>而Consumer 2调用CreateFontDescriptor API创建了FontDescriptor对象desc；</li><li>再基于desc对象创建Font对象font；</li><li>最后计算font对象的LeadingSpace值。</li></ol><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/02.png" alt="图 2：不同的fuzz driver组合⽅式"><figcaption aria-hidden="true">图 2：不同的fuzz driver组合⽅式</figcaption></figure><p>图2是简化出来的API调⽤序列。(a)是原始的调⽤序列，(b)是我们将Consumer 1与Consumer 2进⾏了⼀个交叉变换，将Consumer 1的序列号1调⽤与Consumer 2的序列号4调⽤交换，但我们会发现，这个交叉变换并没有⽤。因为1与4的调换，只是改变了从raw data创建font对象的⽅式，并没有改变后续API调⽤的语义，后续的2-&gt;5，2-&gt;3都是没有变化的。所以我们其实是想要 (c)这种的组合，将3调⽤与5调⽤组合在⼀起。并且可能由于调⽤时序的不同会有意想不到的结果。⽐如先调⽤3计算LeadingSpace的double值，再调⽤5计算LeadingSpace可能会导致整数溢出漏洞。</p><p>从这个例⼦来看单纯依赖⼈⼯进⾏fuzz driver 构建耗费时间且容易出（error-prone）。需要⼀个⾃动化的框架来辅助完成这个fuzz driver构建过程。</p><h1 id="系统总览"><strong>02 系统总览</strong></h1><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/03.png" alt="图 3：APICraft系统总览"><figcaption aria-hidden="true">图 3：APICraft系统总览</figcaption></figure><p>我们设计并实现了APICraft系统⽤于针对闭源SDK fuzz driver⾃动化⽣成⼯作。图3是整体的系统框架总览。APICraft整体设计思路可以概括为Collect-Combine。</p><ol type="1"><li><p><strong>Collect</strong>：APICraft会对使⽤相关SDK的GUI应⽤程序进⾏动态trace，⽤于收集GUI应⽤程序的动态行为信息，包括GUI应⽤程序调⽤SDK API的data dependency以及control dependency等。</p></li><li><p><strong>Combine</strong>：随后将这些dependency解析好之后进行多目标优化的遗传算法（Multi-Objective genetic algorithm）的变异进化。产生合乎我们要求的fuzz driver。</p></li></ol><h1 id="框架设计"><strong>03 框架设计</strong></h1><p>框架设计章节将详细介绍APICraft框架的设计与实现细节。</p><h2 id="api-function-dependency信息收集"><strong>3.1 API Function Dependency信息收集</strong></h2><p>⾸先是如何收集（Collect）API function dependency信息。APICraft最终目标是想自动化的完成fuzz driver 构建过程，而人工构建fuzz driver最核⼼的部分基于SDK提供的API构建API调⽤序列，API调⽤序列包含了data dependency以及control dependency。APICraft需要收集data dependency以及control dependency信息，⽤于作为后续的多目标遗传算法的变异进化的基因/染⾊体。</p><h3 id="data-dependency"><strong>3.1.1 Data Dependency</strong></h3><h4 id="定义"><strong>3.1.1.1 定义</strong></h4><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/04.png" alt="图 4：Data Dependency定义"><figcaption aria-hidden="true">图 4：Data Dependency定义</figcaption></figure><p>在data dependency中，APICraft定义两个函数A与B有data dependency的关系在于，函数A的某个输⼊参数是函数B的输出参数/返回值，或者函数B的某个输⼊参数是函数A的输出参数/返回值。如果函数A与B存在data dependency，以图4的公式来表征，即函数A的输出参数/返回值会被⽤作函数B的输⼊参数。</p><p>APICraft定义了两类的API Data Dependency：</p><ol type="1"><li><p><strong>return value</strong>：函数A的返回值（return value）被⽤做函数B的输⼊参数；</p></li><li><p><strong>output parameter</strong>：函数A的输出参数（output paramater，⼀般是以指针形式存在）被用做函数B的输⼊参数。</p></li></ol><p>如果两个API函数满足data dependency关系，那这两个API函数就有时序调⽤关系。</p><h4 id="解析"><strong>3.1.1.2 解析</strong></h4><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/05.png" alt="图 5：APICraft实现框架图"><figcaption aria-hidden="true">图 5：APICraft实现框架图</figcaption></figure><p>当APICraft收集完程序动态行为信息后，需要将信息解析成相应的data dependency。具体的解析步骤是：</p><ol type="1"><li><p>由图5所示，在预处理阶段，APICraft会通过SDK提供的头⽂件解析出每个API的参数与返回值的类型信息；</p></li><li><p>而参数与返回值的值是由动态获取到的，<strong>APICraft基于function interposition机制实现了⼀套轻量级的动态trace框架</strong>，基于该trace框架，APICraft能够获取到动态运⾏过程中API函数进入前以及退出之后的参数与返回值信息，具体包括了thread id，nested level，以及会递归的将函数的参数值，返回值，输出参数值dump出来；</p></li><li><p>APICraft基于thread id来将不同线程的trace信息区分开；</p></li><li><p>APICraft会筛掉nested level大于1的API。APICraft针对的API函数都是SDK头⽂件⾥⾯提供的合法调⽤API。在动态trace过程，如果某个API不是由其他API所调⽤，即由我们的GUI应⽤所调⽤，他的nested level就是1，如果该API是在另外的API所调⽤的，那他的nested level就是2，以此类推。在fuzz driver⽣成的应⽤场景中，我们关注的是API函数如何正确地被GUI应⽤所调⽤，而不关注API内部调⽤的逻辑。APICraft需要演化学习的是GUI应⽤程序的程序行为逻辑，因此不关注SDK库内部调用的逻辑；</p></li><li><p>区分输出参数：如果⼀个参数类型是指针，APICraft会监控该指针指向的内容在进API函数前，以及退出API函数之后是否有变化，如果有的话，则该参数会被判别为输出参数；</p></li><li><p>结合类型（type）信息以及值（value）信息进⾏data dependency匹配：APICraft认为即使在类型信息⼀致的情况下，两个值为0的⽐对是不匹配的，因为值为0基本⽆意义。随后APICraft会将typedef给展开，如果类型不⼀致，APICraft会看两个比对对象的类型信息是否能够转换，如果（1） 两个比对对象的基本类型是⼀致的，只是修饰符不⼀样，比如const这种修饰词；（2）如果是指针类型的话，并且两者指针⼤小⼀致，或者对象之⼀指针是void*类型的。上述情形都是可转换的，两个对象可被匹配上。</p></li></ol><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/06.png" alt="图 6：Data Dependency解析算法"><figcaption aria-hidden="true">图 6：Data Dependency解析算法</figcaption></figure><p>图6所示算法是APICraft Data Dependency解析算法，输⼊T是收集到的API函数的调⽤序列信息，输出R是解析完的data dependency的集合。</p><p>1.初始化阶段，R以及cache都将初始化为空；</p><p>2.算法会遍历每个函数A，在第8⾏中，算法会将output值不为0的函数加⼊cache中，cache是个字典类型，key为output的值，value为函数A的 output实例；</p><p>3.在第4⾏中，算法会遍历函数的每个输⼊参数（input parameter），用输⼊参数的值（value）当作key从cache中取出相应的函数的output，看看是否有函数的输⼊参数与另外函数的output类型与值匹配上的。如果有的话就加到集合R中。</p><h4 id="dependency推测"><strong>3.1.1.3 Dependency推测</strong></h4><p>除了通过动态trace收集到的API data dependency关系，有些合理的API data dependency关系并不会被trace到（GUI应⽤程序没有相应的 API调⽤组合）。APICraft还会做dependency推测（inference）这⼀步。APICraft定义了三个推测规则：</p><ol type="1"><li><p><strong>R1: Dependency-based transition</strong>：如果函数A的output与函数C的输⼊参数相匹配，并且函数B的output与函数C的输⼊参数相匹配，以及又trace到，函数A的output与函数D的输⼊参数相匹配， APICraft会推断出，函数B的output跟函数D的输⼊参数能够相匹配并产生⼀组data dependency关系；</p></li><li><p><strong>R2: Type-based transition</strong>：当APICraft观察到函数A的output的类型信息与函数B的输⼊参数类型信息⼀致，这个时候APICraft会做个推测，因为这⾥没有值（value）信息，所以是个推测，推测出函数A的 output是函数B的输⼊参数；</p></li><li><p><strong>R3: Inter-thread data flow dependency</strong>：R3与图6的算法是⼀致的，只不过在这个规则下，会限定类型是指针，⼀般跨线程之间会传递指针，需要减少误报。</p></li></ol><h3 id="control-dependency"><strong>3.1.2 Control Dependency</strong></h3><p>APICraft收集到的Control Dependency主要是⽤来解决error code checking的：</p><ol type="1"><li><p>API函数的输出参数（output parameter）或者返回值（return value）是指针类型，将对这个output值 进⾏⾮空判断（null check）；</p></li><li><p>API函数的输出参数（output parameter）或者返回值（return value）是整数类型，并且是个status code的话，将进行动态污点分析来获取error code checking分⽀的表达式。（1）获取这个API函数的调用处（callsite）；（2）通过静态分析找到⼀些error code checking的系统调用，比如exit，abort 等。这些basic block会被标记为checkpoint。（3）最后从调用处（callsite）开始进行taint analysis，因为正常的GUI应用程序会走正常分⽀，当走到checkpoint相应分⽀的时候将表达式取反， 让污点分析传播到checkpoint处。拿到对应的表达式。</p></li></ol><h2 id="dependency-combination"><strong>3.2 Dependency Combination</strong></h2><p>APICraft将收集并解析完成的data dependency以及control denpendency进行Combination，再通过多目标优化遗传算法进行变异演化。</p><h3 id="问题建模"><strong>3.2.1 问题建模</strong></h3><p>APICraft将fuzz driver⽣成问题抽象成⼀个数学问题，利用多目标优化遗传算法（Multi-Objective Genetic Algorithm）进行求解。</p><p>具体而言，以GUI应用程序（调用相应 SDK提供的 API）的API函数使用方式为初始种群，对这些种群进⾏变异演化生成fuzz driver，通过判断生成的fuzz driver的优劣，将优越fuzz driver保留下来继续变异，最后生成满足要求的fuzz driver 用于fuzzing。我们认为<strong>⼀个高质量的fuzz driver需要满足三个⽬标</strong>：</p><ol type="1"><li><p><strong>多样性（Diversity）</strong>：多样性（Diversity）指的是fuzz driver能够调⽤⾜够多样的API使fuzz driver程序行为更丰富。即为了让生成出来的fuzz driver有更多不同的data dependencies，如果data dependencies能够组成loop，每条loop都会给这个目标加分数。图7所示的多样性（Diversity）的公式是生成的fuzz driver的有向多边图的边（即单个data dependency）的数量，加上这个图的圈复杂度。总体是要表征data dependency图（或者说fuzz driver的API调⽤）的多样性。 <img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/7.png" alt="图 7：Diversity公式"></p></li><li><p><strong>有效性（Effectiveness）</strong>：有效性（Effectiveness）是这三个指标中的唯⼀⼀个需要动态反馈信息的指标，其目标是要让⽣成的fuzz driver的API调用更合法有效。我们会给basic blocks中有调用其他函数的，以及这个basic block处于loop循环中的更多分数，因为我们觉得相对于核心代码而言error handling code在⼀个API函数中会执行更少的basic blocks，而核⼼代码会有更多的loop信息或者其 他函数调用。该指标是个动态的feedback，是需要将fuzz driver序列化成代码编译运行后得来的，我们对每个basic block评分：（1）调⽤其余函数以及处于loop循环中，评分3分；（2）调⽤其余函数或者处于loop循环中，2分；（3）两者均⽆则1分。</p></li><li><p><strong>紧凑性（Compactness）</strong>：core dependency指的是从接收input file的API函数为起点，以此为根结点的展开的data dependency图。non-core dependency就是与这颗树无关的data dependency。F是core function（处于 core dependency中的函数）集合，f是集合⾥⾯的每个函数，If是每个函数的参数集合。k是每个input参数的无关函数数量，5是个经验值（即如果无关函数数量超过5，则该紧凑性（Compactness）指标得分为0）。</p></li></ol><p>紧凑性（Compactness）指标⽬的是为了让fuzz driver去除冗余API调⽤，冗余API调用就是跟以接收input file API为起点的data dependency 图无关的API调用，即存在于non-core dependency图中的API调用。所以在core dependency的data dependency分数会高，non-core dependency中的data dependency分数会低。图8是Compactness的具体公式。</p><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/8.png" alt="图 8：Compactness公式"><figcaption aria-hidden="true">图 8：Compactness公式</figcaption></figure><h3 id="多标优化遗传算法multi-objective-genetic-algorithm"><strong>3.2.2 多⽬标优化遗传算法（Multi-Objective Genetic Algorithm）</strong></h3><p>APICraft采用了NSGA-II算法来对Diversity、Effectiveness、Compactness这三个目标进行多目标优化的遗传算法演进。</p><p>图9是整体的APICraft的多目标优化遗传算法，输入data dependency集合，输出是⼀系列的fuzz driver集合：</p><ol type="1"><li><p>25-31行即传统的遗传算法，先生成初始的种子集，选取初始种子集，然后开始变异，再选择存活下来的个体，继续变异，往复。直到到了我们限定的变异轮数。28行进行变异，29行选取最优个体；</p></li><li><p>17-23行选取两个种⼦进⾏交叉变异；</p></li><li><p>11-16行对交叉变异后的种⼦进行多目标优化的评分计算，然后筛出最优个体。12行计算目标评分，13行进行非支配排序算法，进行分层。14行计算拥挤度与拥挤度比较算子。15行筛选出来最优个体；</p></li><li><p>1-10行就是对个体先进行序列化后，计算三个目标的分值。</p></li></ol><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/9.png" alt="图 9：APICraft的多⽬标优化遗传算法"><figcaption aria-hidden="true">图 9：APICraft的多⽬标优化遗传算法</figcaption></figure><h1 id="实现"><strong>04 实现</strong></h1><p>APICraft⼯程实现中核⼼之⼀是动态trace功能，动态trace是为了获取API函数的参数以及返回值。如图10所示，在hook中有两种机制：</p><ol type="1"><li><p>Type-I需要两个hook点，函数的enter point以及exit point，enter point容易分析，但函数的exit point⽆法准确判断，因为⼀个函数可能会有多个exit点，单纯通过判断ret指令是无法精确判断exit点的，特别是当⼆进制程序被高度编译优化过。错误的exit点的hook机制会导致后续收集的nested level等信息都有误；</p></li><li><p>Type-II则没有这个问题，基于interposition的机制是中间有个媒介层在进⼊函数前接管，在退出函数之后也接管。我们就能准确拿到参数值以及返回值。Interposition机制的核心是会有⼀个跟被hook函数相同函数签名的替换函数，然后基于这个替换函数接管原函数的信息之后再调用原函数。在macOS上 APICraft用DYLD_PRELOAD跟DYLD_INTERPOSE机制来实现，在Windows上我们用的是detour来实现。</p></li></ol><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/10.png" alt="图 10：两种 hook机制"><figcaption aria-hidden="true">图 10：两种 hook机制</figcaption></figure><h1 id="实验结果"><strong>05 实验结果</strong></h1><h2 id="多目标优化遗传算法"><strong>5.1 多目标优化遗传算法</strong></h2><p>我们⼀共对5个攻击面进⾏了漏洞挖掘，包含了Image，Font，PDF，Audio，RTF，这里用Image这个攻击面来看看我们算法的实验效果，其他攻击面实验效果可查阅论文。</p><ol type="1"><li><p>图11左图是经过多目标遗传算法生成的fuzz driver跟人工写的fuzz driver在fuzzing过程中覆盖率比对。紫⾊的线是APICraft生成的fuzz driver，浅⾊线是Google Project Zero的安全研究员⼿写的fuzz driver，这个fuzz driver是研究员在对攻击面熟悉，并且通过逆向构建出来的fuzz driver。实验来看， 通过APICraft产生的fuzz driver在fuzzing过程中的覆盖率仍比P0顶尖安全研究员⼿写的fuzz driver实验效果卓越；</p></li><li><p>图11右图是三个⽬标（Diversity、Effectiveness、Compactness）都结合起来生成的fuzz driver跟去掉每⼀个单⼀目标而生成的fuzz driver比对，比如绿色这条线是去掉多样性（Diversity）的覆盖率，去掉每个单⼀目标的实验效果没有三个目标都结合起来生成的fuzz driver在fuzzing过程中的实验效果好。</p></li></ol><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/11.png" alt="图 11：图⽚攻击⾯的多⽬标优化遗传算法实验效果"><figcaption aria-hidden="true">图 11：图⽚攻击⾯的多⽬标优化遗传算法实验效果</figcaption></figure><h2 id="漏洞挖掘产出"><strong>5.2 漏洞挖掘产出</strong></h2><p>基于APICraft⽣成的fuzz driver，我们进行了长达8个月的fuzzing。最终在macOS系统库5个攻击面上发现了<strong>142</strong>处漏洞，收到Apple <strong>54</strong>个官⽅漏洞致谢（该数据统计截⽌到论⽂投稿时，2021年2⽉）。</p><p>图12节选了⼀些漏洞，每⼀列分别是攻击面（Attack Surface），获取到的CVE号或者 Issue-ID，macOS的复现版本，漏洞类型，已经能在哪些 APP上⾯复现这些bug。</p><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/APICraft/12.png" alt="图 12：漏洞挖掘产出"><figcaption aria-hidden="true">图 12：漏洞挖掘产出</figcaption></figure><h1 id="总结"><strong>06 总结</strong></h1><p><strong>APICraft基于function interposition技术实现了轻量级的GUI应用程序动态行为收集框架，以及基于NSGA—II多目标优化遗传算法实现的fuzz driver自动化生成框架</strong>。基于APICraft框架生成的fuzz driver在fuzzing过程中帮助我们挖掘到了macOS系统库<strong>142</strong>处漏洞，共收获Apple <strong>54</strong>个官⽅漏洞致谢。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Fuzzing/" class="category-chain-item">Fuzzing</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Fuzzing/" class="print-no-link">#Fuzzing</a> <a href="/tags/Program-Analysis/" class="print-no-link">#Program Analysis</a> <a href="/tags/Fuzz-Driver/" class="print-no-link">#Fuzz Driver</a></div></div><div class="license-box my-3"><div class="license-title"><div>APICraft：Fuzz Driver Generation for Closed-source SDK Libraries</div><div>https://mundi-xu.github.io/2021/11/28/APICraft-Fuzz-Driver-Generation-for-Closed-source-SDK-Libraries/</div></div><div class="license-meta"><div class="license-meta-item"><div>Author</div><div>煊宇</div></div><div class="license-meta-item license-meta-date"><div>Posted on</div><div>November 28, 2021</div></div><div class="license-meta-item"><div>Licensed under</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/" rel="external nofollow noreferrer"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-cc-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/" rel="external nofollow noreferrer"><span class="hint--top hint--rounded" aria-label="NC - Non-commercial"><i class="iconfont icon-cc-nc"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2021/11/29/why-ml-fails-security/" title="【转载】为什么机器学习解决网络安全问题总是失败"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">【转载】为什么机器学习解决网络安全问题总是失败</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/2021/11/26/Common-vulnerabilities-mitigation-measures/" title="常见漏洞缓解措施"><span class="hidden-mobile">常见漏洞缓解措施</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="giscus" class="giscus"></div><script type="text/javascript">Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"Mundi-Xu/mundi-xu.github.io","repo-id":"MDEwOlJlcG9zaXRvcnkxNTQ1OTg4Mjg=","category":"Announcements","category-id":"DIC_kwDOCTb9rM4CeUGi","theme-light":"light","theme-dark":"dark","mapping":"title","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN","strict":0};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>Table of Contents</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="mailto:mundi.xu@gmail.com?subject=Interested+In+Your+Blog" rel="external nofollow noreferrer" target="_blank"><span>Contact me</span></a> <i class="iconfont icon-love"></i> <a href="mailto:mundi.xu@gmail.com?subject=Interested+In+Your+Blog" rel="external nofollow noreferrer" target="_blank"><span>mundi.xu@gmail.com</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">Views: <span id="busuanzi_value_site_pv"></span> </span><span id="busuanzi_container_site_uv" style="display:none">Visitors: <span id="busuanzi_value_site_uv"></span></span></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.2/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/typed.js/2.1.0/typed.umd.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>var relativeDate=function(){var t,e,a,d,i=document.getElementById("updated-time");i&&(e=/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/,(a=(t=i.textContent).match(e))&&(d=dayjs(a[0]).fromNow(),i.textContent=t.replace(e,d)),i.style.display="")};Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/dayjs.min.js",function(){Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/plugin/relativeTime.min.js",function(){dayjs.extend(dayjs_plugin_relativeTime),"en".startsWith("en")?relativeDate():Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/locale/en.min.js",function(){dayjs.locale("en"),relativeDate()})})})</script><script>Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.36.4/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://cdnjs.cloudflare.com/ajax/libs/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/DynamicLine.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>