<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon_io/apple-touch-icon.png"><link rel="icon" href="/img/favicon_io/favicon.ico"><link rel="canonical" href="https://mundi-xu.github.io/2020/12/27/A-Brief-Analysis-of-Cryptographic-Algorithm-RUST/"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="煊宇"><meta name="keywords" content="LLM Security"><meta property="article:published_time" content="2020-12-27T06:05:31.000Z"><meta property="article:modified_time" content="2020-12-28T02:30:00.000Z"><meta property="article:section" content="Security Research"><meta property="article:tag" content="Cryptography"><meta property="article:tag" content="Symmetric Cryptography"><meta property="article:tag" content="Asymmetric Cryptography"><meta property="article:tag" content="rust"><meta name="google-site-verification" content="8weHOmi2lqvnOxDE30WJFT51umo63nyCgfm8dXHNT5g"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><link rel="dns-prefetch" href="//at.alicdn.com"><link rel="dns-prefetch" href="//cdnjs.cloudflare.com"><link rel="dns-prefetch" href="//raw.githubusercontent.com"><link rel="dns-prefetch" href="//busuanzi.ibruce.info"><link rel="preconnect" href="https://at.alicdn.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="preconnect" href="https://busuanzi.ibruce.info" crossorigin><link rel="dns-prefetch" href="//www.googletagmanager.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin><link rel="preload" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css" as="style" onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"></noscript><link rel="preload" href="/css/main.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/events.js" as="script"><link rel="preload" href="/js/plugins.js" as="script"><link rel="preload" href="/js/boot.js" as="script"><link rel="preload" href="/js/img-lazyload.js" as="script"><meta name="description" content="基于Rust语言开发的在线加解密系统，深入分析仿射密码、流密码、分组密码等多种密码学算法原理与实现。从古典密码学到现代密码学，探索RSA、RC4、DES、AES等核心加密技术的工作机制。"><meta property="og:type" content="article"><meta property="og:title" content="密码学初探-基于RUST的密码系统与算法简析"><meta property="og:url" content="https://mundi-xu.github.io/2020/12/27/A-Brief-Analysis-of-Cryptographic-Algorithm-RUST/index.html"><meta property="og:site_name" content="Hanyin&#39;s Space"><meta property="og:description" content="基于Rust语言开发的在线加解密系统，深入分析仿射密码、流密码、分组密码等多种密码学算法原理与实现。从古典密码学到现代密码学，探索RSA、RC4、DES、AES等核心加密技术的工作机制。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/affine.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/n-fsr.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/lfsr-1.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/lfsr-2.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/combine-generator.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/JK-1.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/JK-2.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/JK-3.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/lfsr-jk.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/rc4_s_t.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/rc4_s.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/rc4_key.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/rc4.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%AF%94%E8%BE%83.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/iterated_cipher.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/des.gif"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/f-function.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/aes_data_unit.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/aes_block2state.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/aes_plain2state.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/aes_details.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/aes_enc_dec.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/aes_subbytes.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/aes_key_expansion.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/rsa.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/DH-1.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/DH-3.png"><meta property="og:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/DH-2.png"><meta property="article:published_time" content="2020-12-27T06:05:31.000Z"><meta property="article:modified_time" content="2020-12-28T02:30:00.000Z"><meta property="article:author" content="煊宇"><meta property="article:tag" content="Asymmetric Cryptography"><meta property="article:tag" content="Cryptography"><meta property="article:tag" content="Symmetric Cryptography"><meta property="article:tag" content="rust"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E7%B3%BB%E7%BB%9F/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81.png"><meta name="format-detection" content="telephone=no"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hanyin&#39;s Space"><meta name="referrer" content="no-referrer-when-downgrade"><meta name="renderer" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link rel="apple-touch-icon" sizes="180x180" href="/img/favicon_io/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon_io/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon_io/favicon-16x16.png"><link rel="manifest" href="/img/favicon_io/site.webmanifest"><script type="application/ld+json">{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "密码学初探-基于RUST的密码系统与算法简析",
    "author": {
      "@type": "Person",
      "name": "煊宇"
    },
    "datePublished": "2020-12-27T06:05:31.000Z",
    
    "dateModified": "2020-12-28T02:30:00.000Z",
    
    "description": "基于Rust语言开发的在线加解密系统，深入分析仿射密码、流密码、分组密码等多种密码学算法原理与实现。从古典密码学到现代密码学，探索RSA、RC4、DES、AES等核心加密技术的工作机制。",
    
    "publisher": {
      "@type": "Organization",
      "name": "Hanyin&#39;s Space",
      
      "logo": {
        "@type": "ImageObject",
        "url": "/img/favicon_io/favicon.ico"
      }
      
    },
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://mundi-xu.github.io/2020/12/27/A-Brief-Analysis-of-Cryptographic-Algorithm-RUST/index.html"
    },
    
    "keywords": "Cryptography,Symmetric Cryptography,Asymmetric Cryptography,rust",
    
    
    "articleBody": "Introduction 密码学（Cryptography）一般可分为古典密码学和现代密码学。 其中，古典密码学，作为一种实用性艺术存在，其编码和破译通常依赖于设计者和敌手的创造力与技巧，并没有对密码学原件进行清晰的定义。古典密码学主要包含以下几个方面：  单表替换加密（Monoalphabetic Cipher） 多表替换加密（Polyalphabetic Cipher） 奇奇怪怪的加密方式  而现代密码学则起源于 20 世纪中后期出现的大量相关理论，1949 年香农（C. E. Shannon）发表了题为《保密系统的通信理论》的经典论文标志着现代密码学的开始。现代密码学主要包含以下几个方面：  对称加密（Symmetric Cryptography），以 DES，AES，RC4 为代表。 非对称加密（Asymmetric Cryptography），以 RSA，ElGamal，椭圆曲线加密为代表。 哈希函数（Hash Function），以 MD5，SHA-1，SHA-512 等为代表。 数字签名（Digital Signature），以 RSA 签名，ElGamal 签名，DSA"
    
  }</script><title>密码学初探-基于RUST的密码系统与算法简析 - Hanyin&#39;s Space</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.2/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hint.css/3.0.0/hint.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"mundi-xu.github.io",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:3},web_analytics:{enable:!0,follow_dnt:!1,google:{measurement_id:"G-3847WCVNF2"}},search_path:"/local-search.json",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-3847WCVNF2",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","G-3847WCVNF2")})</script><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="Hanyin's Space" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Hanyin&#39;s Space</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>Home</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>Archives</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>Categories</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>Tags</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>About</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>Links</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" rel="external nofollow noreferrer" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" rel="external nofollow noreferrer" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="密码学初探-基于RUST的密码系统与算法简析"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-12-27 14:05" pubdate>December 27, 2020 pm</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 14k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 119 mins </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> views</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Security Research" id="heading-ef1cd54fe461bafc9bc1f6892b96d498" role="tab" data-toggle="collapse" href="#collapse-ef1cd54fe461bafc9bc1f6892b96d498" aria-expanded="true">Security Research <span class="list-group-count">(11)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-ef1cd54fe461bafc9bc1f6892b96d498" role="tabpanel" aria-labelledby="heading-ef1cd54fe461bafc9bc1f6892b96d498"><div class="category-post-list"><a href="/2023/08/03/CVE-2022-3901-Container-Escape-via-File-based-DirtyCred/" title="CVE-2022-3901：利用DirtyCred进行容器逃逸" class="list-group-item list-group-item-action"><span class="category-post">CVE-2022-3901：利用DirtyCred进行容器逃逸</span> </a><a href="/2022/10/08/DirtyCred/" title="DirtyCred与CVE-2021-4154漏洞分析" class="list-group-item list-group-item-action"><span class="category-post">DirtyCred与CVE-2021-4154漏洞分析</span> </a><a href="/2021/11/30/Architectural-Support-for-System-Security/" title="Architectural Support for System Security" class="list-group-item list-group-item-action"><span class="category-post">Architectural Support for System Security</span> </a><a href="/2021/11/29/why-ml-fails-security/" title="【转载】为什么机器学习解决网络安全问题总是失败" class="list-group-item list-group-item-action"><span class="category-post">【转载】为什么机器学习解决网络安全问题总是失败</span> </a><a href="/2021/11/26/Common-vulnerabilities-mitigation-measures/" title="常见漏洞缓解措施" class="list-group-item list-group-item-action"><span class="category-post">常见漏洞缓解措施</span> </a><a href="/2021/07/15/Chromium-component-risk-analysis/" title="【转载】攻防启示：Chromium 组件风险剖析与收敛" class="list-group-item list-group-item-action"><span class="category-post">【转载】攻防启示：Chromium 组件风险剖析与收敛</span> </a><a href="/2021/02/23/recent-technology-of-symbolic-execution/" title="【转载】带你搞懂符号执行的前世今生与最近技术" class="list-group-item list-group-item-action"><span class="category-post">【转载】带你搞懂符号执行的前世今生与最近技术</span> </a><a href="/2021/01/01/A-brief-analysis-of-PayBreak-anti-ransomware-system/" title="PayBreak防勒索系统简析" class="list-group-item list-group-item-action"><span class="category-post">PayBreak防勒索系统简析</span> </a><a href="/2020/12/28/Research-on-Ransomware-Structure-and-Encryption-Mode/" title="勒索软件结构与加密模式研究" class="list-group-item list-group-item-action"><span class="category-post">勒索软件结构与加密模式研究</span> </a><a href="/2020/12/27/A-Brief-Analysis-of-Cryptographic-Algorithm-RUST/" title="密码学初探-基于RUST的密码系统与算法简析" class="list-group-item list-group-item-action active"><span class="category-post">密码学初探-基于RUST的密码系统与算法简析</span> </a><a href="/2020/07/01/Blockchain-based-security-log-system/" title="基于区块链的安全日志系统" class="list-group-item list-group-item-action"><span class="category-post">基于区块链的安全日志系统</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">密码学初探-基于RUST的密码系统与算法简析</h1><p id="updated-time" class="note note-primary" style="display:none">Last updated on 2020-12-28T10:30:00+08:00</p><div class="markdown-body"><h1 id="introduction">Introduction</h1><p>密码学（Cryptography）一般可分为古典密码学和现代密码学。</p><p>其中，古典密码学，作为一种实用性艺术存在，其编码和破译通常依赖于设计者和敌手的创造力与技巧，并没有对密码学原件进行清晰的定义。古典密码学主要包含以下几个方面：</p><ul><li>单表替换加密（Monoalphabetic Cipher）</li><li>多表替换加密（Polyalphabetic Cipher）</li><li>奇奇怪怪的加密方式</li></ul><p>而现代密码学则起源于 20 世纪中后期出现的大量相关理论，1949 年香农（C. E. Shannon）发表了题为《保密系统的通信理论》的经典论文标志着现代密码学的开始。现代密码学主要包含以下几个方面：</p><ul><li>对称加密（Symmetric Cryptography），以 DES，AES，RC4 为代表。</li><li>非对称加密（Asymmetric Cryptography），以 RSA，ElGamal，椭圆曲线加密为代表。</li><li>哈希函数（Hash Function），以 MD5，SHA-1，SHA-512 等为代表。</li><li>数字签名（Digital Signature），以 RSA 签名，ElGamal 签名，DSA 签名为代表。</li></ul><p>其中，对称加密体制主要分为两种方式：</p><ul><li>分组密码（Block Cipher），又称为块密码。</li><li>序列密码（Stream Cipher），又称为流密码。</li></ul><p>一般来说，密码设计者的根本目标是保障信息及信息系统的</p><ul><li>机密性（Confidentiality）</li><li>完整性（Integrity）</li><li>可用性（Availability）</li><li>认证性（Authentication）</li><li>不可否认性（Non-repudiation）</li></ul><p>其中，前三者被称为信息安全的 CIA 三要素 。</p><p>本文主要介绍了仿射密码，流密码（RC4,LFSR+JK)，分组密码（DES,AES），非对称加密（rsa）和密码协议（Diffie_Hellman）。 项目详细代码已于Github开源<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="">[1]</span></a></sup>。</p><h1 id="仿射密码">仿射密码</h1><h2 id="原理">原理</h2><p>仿射密码的加密函数是 <span class="math inline">\(E(x)=(ax+b)\pmod m\)</span>，其中</p><ul><li><span class="math inline">\(x\)</span> 表示明文按照某种编码得到的数字</li><li><span class="math inline">\(a\)</span> 和 <span class="math inline">\(m\)</span> 互质</li><li><span class="math inline">\(m\)</span> 是编码系统中字母的数目。</li></ul><p>解密函数是 <span class="math inline">\(D(x)=a^{-1}(x-b)\pmod m\)</span>，其中 <span class="math inline">\(a^{-1}\)</span> 是 <span class="math inline">\(a\)</span> 在 <span class="math inline">\(\mathbb{Z}_{m}\)</span> 群的乘法逆元。</p><p>下面我们以 <span class="math inline">\(E(x) = (5x + 8) \bmod 26\)</span> 函数为例子进行介绍，加密字符串为 <code>AFFINE CIPHER</code>，这里我们直接采用字母表26个字母作为编码系统</p><table style="width:100%"><thead><tr><th>明文</th><th>A</th><th>F</th><th>F</th><th>I</th><th>N</th><th>E</th><th>C</th><th>I</th><th>P</th><th>H</th><th>E</th><th>R</th></tr></thead><tbody><tr><td>x</td><td>0</td><td>5</td><td>5</td><td>8</td><td>13</td><td>4</td><td>2</td><td>8</td><td>15</td><td>7</td><td>4</td><td>17</td></tr><tr><td><span class="math inline">\(y=5x+8\)</span></td><td>8</td><td>33</td><td>33</td><td>48</td><td>73</td><td>28</td><td>18</td><td>48</td><td>83</td><td>43</td><td>28</td><td>93</td></tr><tr><td><span class="math inline">\(y\mod26\)</span></td><td>8</td><td>7</td><td>7</td><td>22</td><td>21</td><td>2</td><td>18</td><td>22</td><td>5</td><td>17</td><td>2</td><td>15</td></tr><tr><td>密文</td><td>I</td><td>H</td><td>H</td><td>W</td><td>V</td><td>C</td><td>S</td><td>W</td><td>F</td><td>R</td><td>C</td><td>P</td></tr></tbody></table><p>其对应的加密结果是 <code>IHHWVCSWFRCP</code>。</p><p>对于解密过程，正常解密者具有a与b，可以计算得到 <span class="math inline">\(a^{-1}\)</span> 为 21，所以其解密函数是<span class="math inline">\(D(x)=21(x-8)\pmod {26}\)</span> ，解密如下</p><table><thead><tr><th>密文</th><th style="text-align:left">I</th><th style="text-align:left">H</th><th>H</th><th>W</th><th>V</th><th>C</th><th>S</th><th>W</th><th>F</th><th>R</th><th>C</th><th>P</th></tr></thead><tbody><tr><td><span class="math inline">\(y\)</span></td><td style="text-align:left">8</td><td style="text-align:left">7</td><td>7</td><td>22</td><td>21</td><td>2</td><td>18</td><td>22</td><td>5</td><td>17</td><td>2</td><td>15</td></tr><tr><td><span class="math inline">\(x=21(y-8)\)</span></td><td style="text-align:left">0</td><td style="text-align:left">-21</td><td>-21</td><td>294</td><td>273</td><td>-126</td><td>210</td><td>294</td><td>-63</td><td>189</td><td>-126</td><td>147</td></tr><tr><td><span class="math inline">\(x\mod26\)</span></td><td style="text-align:left">0</td><td style="text-align:left">5</td><td>5</td><td>8</td><td>13</td><td>4</td><td>2</td><td>8</td><td>15</td><td>7</td><td>4</td><td>17</td></tr><tr><td>明文</td><td style="text-align:left">A</td><td style="text-align:left">F</td><td>F</td><td>I</td><td>N</td><td>E</td><td>C</td><td>I</td><td>P</td><td>H</td><td>E</td><td>R</td></tr></tbody></table><p>可以看出其特点在于只有 26 个英文字母。</p><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/仿射密码.png" alt="仿射密码"><figcaption aria-hidden="true">仿射密码</figcaption></figure><h2 id="rust实现">Rust实现</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Encrypt</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ans</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-keyword">for</span> <span class="hljs-variable">ch</span> <span class="hljs-keyword">in</span> msg.<span class="hljs-title function_ invoke__">chars</span>() &#123;<br>    <span class="hljs-keyword">if</span> ch.<span class="hljs-title function_ invoke__">is_ascii_alphabetic</span>() &#123;<br>        <span class="hljs-keyword">if</span> ch.<span class="hljs-title function_ invoke__">is_uppercase</span>() &#123;<br>            <span class="hljs-comment">// 大写字母</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = ch <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> - <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = (upper_a * x + upper_b) % <span class="hljs-number">26</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">target</span> = <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> + y;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">new_ch</span> = <span class="hljs-type">char</span>::<span class="hljs-title function_ invoke__">try_from</span>(target).<span class="hljs-title function_ invoke__">unwrap</span>();<br>            ans.<span class="hljs-title function_ invoke__">push</span>(new_ch);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 小写字母</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = ch <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> - <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = (lower_a * x + lower_b) % <span class="hljs-number">26</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">target</span> = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> + y;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">new_ch</span> = <span class="hljs-type">char</span>::<span class="hljs-title function_ invoke__">try_from</span>(target).<span class="hljs-title function_ invoke__">unwrap</span>();<br>            ans.<span class="hljs-title function_ invoke__">push</span>(new_ch);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ch.<span class="hljs-title function_ invoke__">is_ascii_digit</span>() &#123;<br>        <span class="hljs-comment">// 数字</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = ch <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> - <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = (number_a * x + number_b) % <span class="hljs-number">26</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">target</span> = <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> + y;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">new_ch</span> = <span class="hljs-type">char</span>::<span class="hljs-title function_ invoke__">try_from</span>(target).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        ans.<span class="hljs-title function_ invoke__">push</span>(new_ch);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ans.<span class="hljs-title function_ invoke__">push</span>(ch);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(ans);<br><br><br><span class="hljs-comment">// Decrypt</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">lower_a_</span> = <span class="hljs-title function_ invoke__">exgcd</span>(lower_a <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>, <span class="hljs-number">26</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">upper_a_</span> = <span class="hljs-title function_ invoke__">exgcd</span>(upper_a <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>, <span class="hljs-number">26</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">number_a_</span> = <span class="hljs-title function_ invoke__">exgcd</span>(number_a <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>, <span class="hljs-number">10</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ans</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-keyword">for</span> <span class="hljs-variable">ch</span> <span class="hljs-keyword">in</span> msg.<span class="hljs-title function_ invoke__">chars</span>() &#123;<br>    <span class="hljs-keyword">if</span> ch.<span class="hljs-title function_ invoke__">is_ascii_alphabetic</span>() &#123;<br>        <span class="hljs-keyword">if</span> ch.<span class="hljs-title function_ invoke__">is_uppercase</span>() &#123;<br>            <span class="hljs-comment">// 大写字母</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = ch <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> - <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = (upper_a_ * (x + <span class="hljs-number">26</span> - upper_b)) % <span class="hljs-number">26</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">target</span> = <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> + y;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">new_ch</span> = <span class="hljs-type">char</span>::<span class="hljs-title function_ invoke__">try_from</span>(target).<span class="hljs-title function_ invoke__">unwrap</span>();<br>            ans.<span class="hljs-title function_ invoke__">push</span>(new_ch);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 小写字母</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = ch <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> - <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = (lower_a_ * (x + <span class="hljs-number">26</span> - lower_b)) % <span class="hljs-number">26</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">target</span> = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> + y;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">new_ch</span> = <span class="hljs-type">char</span>::<span class="hljs-title function_ invoke__">try_from</span>(target).<span class="hljs-title function_ invoke__">unwrap</span>();<br>            ans.<span class="hljs-title function_ invoke__">push</span>(new_ch);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ch.<span class="hljs-title function_ invoke__">is_ascii_digit</span>() &#123;<br>        <span class="hljs-comment">// 数字</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = ch <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> - <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = (number_a_ * (x + <span class="hljs-number">10</span> - number_b)) % <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">target</span> = <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span> + y;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">new_ch</span> = <span class="hljs-type">char</span>::<span class="hljs-title function_ invoke__">try_from</span>(target).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        ans.<span class="hljs-title function_ invoke__">push</span>(new_ch);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ans.<span class="hljs-title function_ invoke__">push</span>(ch);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(ans);<br></code></pre></td></tr></table></figure><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/affine.png" alt="Affine"><figcaption aria-hidden="true">Affine</figcaption></figure><h2 id="破解">破解</h2><p>首先，我们可以看到的是，仿射密码对于任意两个不同的字母，其最后得到的密文必然不一样，所以其也具有最通用的特点。当密文长度足够长时，我们可以使用频率分析的方法来解决。</p><p>其次，我们可以考虑如何攻击该密码。可以看出当<span class="math inline">\(a=1\)</span> 时，仿射加密是凯撒加密。而一般来说，我们利用仿射密码时，其字符集都用的是字母表，一般只有26个字母，而不大于26的与26互素的个数一共有</p><p><span class="math display">\[ \phi(26)=\phi(2) \times \phi(13) = 12 \]</span></p><p>算上b的偏移可能，一共有可能的密钥空间大小也就是</p><p><span class="math display">\[ 12 \times 26 = 312 \]</span></p><p>一般来说，对于该种密码，我们至少得是在已知部分明文的情况下才可以攻击。下面进行简单的分析。</p><p>这种密码由两种参数来控制，如果我们知道其中任意一个参数，那我们便可以很容易地快速枚举另外一个参数得到答案。</p><p>但是，假设我们已经知道采用的字母集，这里假设为26个字母，我们还有另外一种解密方式，我们只需要知道两个加密后的字母 <span class="math inline">\(y_1,y_2\)</span> 即可进行解密。那么我们还可以知道</p><p><span class="math display">\[ \begin{align} y_1 &amp;= (ax_1+b)\pmod{26} \\ y_2 &amp;= (ax_2+b)\pmod{26} \end{align} \]</span></p><p>两式相减，可得</p><p><span class="math display">\[ \begin{align} y_1-y_2 &amp;= a(x_1-x_2)\pmod{26} \end{align} \]</span></p><p>这里 <span class="math inline">\(y_1,y_2\)</span> 已知，如果我们知道密文对应的两个不一样的字符 <span class="math inline">\(x_1\)</span> 与 <span class="math inline">\(x_2\)</span> ，那么我们就可以很容易得到 <span class="math inline">\(a\)</span> ，进而就可以得到 <span class="math inline">\(b\)</span> 了。</p><h1 id="流密码">流密码</h1><p>流密码一般逐字节或者逐比特处理信息。一般来说</p><ul><li>流密码的密钥长度会与明文的长度相同。</li><li>流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。</li></ul><p>需要注意的是，流加密目前来说都是对称加密。</p><p>伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。</p><p>流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。</p><p>流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。当然，也有一些特殊设计的流密码，比如 RC4。</p><h2 id="反馈移位寄存器">反馈移位寄存器</h2><p>一般的，一个 n 级反馈移位寄存器如下图所示</p><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/n-fsr.png" alt="n-fsr"><figcaption aria-hidden="true">n-fsr</figcaption></figure><p>其中</p><ul><li><span class="math inline">\(a_0\)</span>，<span class="math inline">\(a_1\)</span>，…，<span class="math inline">\(a_{n-1}\)</span> 为初态。</li><li>F 为反馈函数或者反馈逻辑。如果 F 为线性函数，那么我们称其为线性反馈移位寄存器（LFSR），否则我们称其为非线性反馈移位寄存器（NFSR）。</li><li><span class="math inline">\(a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1})\)</span> 。</li></ul><p>一般来说，反馈移位寄存器都会定义在某个有限域上，从而避免数字太大和太小的问题。因此，我们可以将其视为同一个空间中的变换，即</p><p><span class="math inline">\((a_i,a_{i+1},...,a_{i+n-1}) \rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n})\)</span> . 对于一个序列来说，我们一般定义其生成函数为其序列对应的幂级数的和。</p><h2 id="线性反馈移位寄存器---lfsr">线性反馈移位寄存器 - LFSR</h2><h3 id="介绍">介绍</h3><p>线性反馈移位寄存器的反馈函数一般如下</p><p><span class="math display">\[a_{i+n}=\sum\limits_{j=1}^{n}c_ja_{i+n-j}\]</span></p><p>其中，<span class="math inline">\(c_j\)</span> 均在某个有限域 <span class="math inline">\(F_q\)</span> 中。</p><p>既然线性空间是一个线性变换，我们可以得知这个线性变换为</p><p><span class="math display">\[ \begin{align} &amp;\left[ a_{i+1},a_{i+2},a_{i+3}, \ldots,a_{i+n} \right] \\ &amp;= \left[ a_{i},a_{i+1},a_{i+2}, \ldots,a_{i+n-1} \right]\left[ \begin{matrix} 0 &amp; 0 &amp; \cdots &amp; 0 &amp; c_n \\ 1 &amp; 0 &amp; \cdots &amp; 0 &amp; c_{n-1} \\ 0 &amp; 1 &amp; \cdots &amp; 0 &amp; c_{n-2} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\ 0 &amp; 0 &amp; \cdots &amp; 1 &amp; c_1 \end{matrix} \right] \\ &amp;= \left[ a_{0},a_{1},a_{2}, \ldots,a_{n-1} \right]\left[ \begin{matrix} 0 &amp; 0 &amp; \cdots &amp; 0 &amp; c_n \\ 1 &amp; 0 &amp; \cdots &amp; 0 &amp; c_{n-1} \\ 0 &amp; 1 &amp; \cdots &amp; 0 &amp; c_{n-2} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\ 0 &amp; 0 &amp; \cdots &amp; 1 &amp; c_1 \end{matrix} \right]^{i+1} \end{align} \]</span></p><p>进而，我们可以求得其特征多项式为</p><p><span class="math display">\[f(x)=x^n-\sum\limits_{i=1}^{n}c_ix^{n-i}\]</span></p><p>同时，我们定义其互反多项式为</p><p><span class="math display">\[\overline f(x)=x^nf(\frac{1}{x})=1-\sum\limits_{i=1}^{n}c_ix^{i}\]</span></p><p>我们也称互反多项式为线性反馈移位寄存器的联结多项式。</p><p>这里有一些定理需要我们记一下，感兴趣的可以自行推导。</p><h3 id="样例">样例</h3><p><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/lfsr-1.png" alt="lfsr-1"> <img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/lfsr-2.png" alt="lfsr-2"></p><h3 id="特征多项式与生成函数">特征多项式与生成函数</h3><p>已知某个 n 级线性反馈移位寄存器的特征多项式，那么该序列对应的生成函数为</p><p><span class="math display">\[A(x)=\frac{p(x)}{\overline f(x)}\]</span></p><p>其中，<span class="math inline">\(p(x)=\sum\limits_{i=1}^{n}(c_{n-i}x^{n-i}\sum\limits_{j=1}^{i}a_jx^{j-1})\)</span>。可以看出 p(x) 完全由初始状态和反馈函数的系数决定。</p><h3 id="序列周期与生成函数">序列周期与生成函数</h3><p>序列的的周期为其生成函数的既约真分式的分母的周期。</p><p>对于 n 级线性反馈移位寄存器，最长周期为 <span class="math inline">\(2^{n}-1\)</span>（排除全零）。达到最长周期的序列一般称为 m 序列。</p><h3 id="特殊性质">特殊性质</h3><ul><li>将两个序列累加得到新的序列的周期为这两个序列的周期的和。</li><li>序列是 n 级 m 序列，当且仅当序列的极小多项式是 n 次本原多项式。</li></ul><h3 id="b-m-算法">B-M 算法</h3><p>一般来说，我们可以从两种角度来考虑 LFSR</p><ul><li>密钥生成角度，一般我们希望使用级数尽可能低的 LFSR 来生成周期大，随机性好的序列。</li><li>密码分析角度，给定一个长度为 n 的序列 a，如何构造一个级数尽可能小的 LFSR 来生成它。其实这就是 B-M 算法的来源。</li></ul><p>一般来说，我们定义一个序列的线性复杂度如下</p><ul><li>若 s 为一个全零序列，则线性复杂度为0。</li><li>若没有 LFSR 能生成 s，则线性复杂度为无穷。</li><li>否则，s 的线性复杂度为生成 L(s) 的最小级的 LFSR。</li></ul><p>BM 算法的要求我们需要知道长度为 2n 的序列。其复杂度</p><ul><li>时间复杂度：O(n^2) 次比特操作</li><li>空间复杂度：O(n) 比特。</li></ul><p>关于 BM 算法的细节，后续添加，目前处于学习过程中。</p><p>但是其实如果我们知道了长度为 2n 的序列，我们也可以一种比较笨的方法来获取原先的序列。不妨假设已知的序列为<span class="math inline">\(a_1,...,a_{2n}\)</span>，我们可以令</p><p><span class="math display">\[S_1=(a_1,...,a_n)\]</span></p><p><span class="math display">\[S_2=(a_2,...,a_{n+1})\]</span></p><p>…</p><p><span class="math display">\[S_{n+1}=(a_{n+1},...,a_{2n})\]</span></p><p>那么我们可以构造矩阵 <span class="math inline">\(X=(S_1,...,S_n)\)</span>，那么</p><p><span class="math display">\[S_{n+1}=(c_n,...,c_1)X\]</span></p><p>所以</p><p><span class="math display">\[(c_n,...,c_1)=S_{n+1}X^{-1}\]</span></p><p>进而我们也就知道了 LFSR 的反馈表达式，进而我们就可以推出初始化种子。</p><h2 id="非线性反馈移位寄存器">非线性反馈移位寄存器</h2><h3 id="介绍-1">介绍</h3><p>为了使得密钥流输出的序列尽可能复杂，会使用非线性反馈移位寄存器，常见的有三种</p><ul><li>非线性组合生成器，对多个 LFSR 的输出使用一个非线性组合函数</li><li>非线性滤波生成器，对一个 LFSR 的内容使用一个非线性组合函数</li><li>钟控生成器，使用一个（或多个）LFSR 的输出来控制另一个（或多个）LFSR 的时钟</li></ul><h3 id="非线性组合生成器">非线性组合生成器</h3><h4 id="简介">简介</h4><p>组合生成器一般如下图所示。</p><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/combine-generator.png" alt="combine-generator"><figcaption aria-hidden="true">combine-generator</figcaption></figure><h4 id="jk触发器">JK触发器</h4><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/JK-1.png" alt="JK-1"><figcaption aria-hidden="true">JK-1</figcaption></figure><h4 id="利用j-k触发器的非线性序列生成器">利用J-K触发器的非线性序列生成器</h4><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/JK-2.png" alt="JK-2"><figcaption aria-hidden="true">JK-2</figcaption></figure><h4 id="样例-1">样例</h4><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/JK-3.png" alt="JK-3"><figcaption aria-hidden="true">JK-3</figcaption></figure><h4 id="rust实现-1">Rust实现</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LfsrJk</span> &#123;<br>    j_state: <span class="hljs-type">u32</span>,<br>    k_state: <span class="hljs-type">u32</span>,<br>    j_state_c: <span class="hljs-type">u32</span>,<br>    k_state_c: <span class="hljs-type">u32</span>,<br>    data_state: <span class="hljs-type">u8</span>,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">LfsrJk</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(j_state: <span class="hljs-type">u32</span>, k_state: <span class="hljs-type">u32</span>, j_state_c: <span class="hljs-type">u32</span>, k_state_c: <span class="hljs-type">u32</span>, data_state: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            j_state: <span class="hljs-number">0x12345678</span> - j_state,<br>            k_state: <span class="hljs-number">0x87654321</span> - k_state,<br>            j_state_c: <span class="hljs-number">0xffffffff</span> - j_state_c,<br>            k_state_c: <span class="hljs-number">0xffffffff</span> - k_state_c,<br>            data_state,<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">crypt</span>(&amp;<span class="hljs-keyword">self</span>, data: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>]) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">j_state</span> = <span class="hljs-keyword">self</span>.j_state;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">k_state</span> = <span class="hljs-keyword">self</span>.k_state;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">data_state</span> = <span class="hljs-keyword">self</span>.data_state;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = data.<span class="hljs-title function_ invoke__">len</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..len &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">j</span> = <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">round</span>(&amp;<span class="hljs-keyword">mut</span> j_state, <span class="hljs-keyword">self</span>.j_state_c);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">k</span> = <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">round</span>(&amp;<span class="hljs-keyword">mut</span> k_state, <span class="hljs-keyword">self</span>.k_state_c);<br>            data_state = j ^ (!(j ^ k) &amp; data_state);<br>            data[i] ^= data_state;<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">#[inline]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">round</span>(state: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">u32</span>, state_c: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">output</span> = <span class="hljs-number">0u8</span>;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">8</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = *state &amp; state_c;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">new_out</span> = t.<span class="hljs-title function_ invoke__">count_ones</span>() % <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">out</span> = (<span class="hljs-number">0x80000000</span> &amp; t) &gt;&gt; <span class="hljs-number">31</span>;<br>            output = (output &lt;&lt; <span class="hljs-number">1</span>) + out <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>;<br>            *state = (*state &lt;&lt; <span class="hljs-number">1</span>) + new_out;<br>        &#125;<br>        output<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/lfsr-jk.png" alt="lfsr-jk"><figcaption aria-hidden="true">lfsr-jk</figcaption></figure><h2 id="rc4">RC4</h2><h3 id="基本介绍">基本介绍</h3><p>RSA 由 Ron Rivest 设计，加解密使用相同的密钥，因此也属于对称加密算法。它是面向字节的流密码，密钥长度可变，非常简单，但也很有效果。RC4 算法曾广泛应用于 SSL/TLS 协议和 WEP/WPA 协议，但由于RC4算法存在弱点，2015年2月所发布的 RFC 7465 规定禁止在TLS中使用RC4加密算法。</p><h3 id="基本流程">基本流程</h3><p>RC4 主要包含三个流程</p><ul><li>初始化 S 和 T 数组。</li><li>初始化置换 S。</li><li>生成密钥流。</li></ul><h4 id="初始化-s-和-t-数组">初始化 S 和 T 数组</h4><p>初始化 S 和 T 的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span> to <span class="hljs-number">255</span> <span class="hljs-keyword">do</span><br>    S[i] = i<br>    T[i] = K[i mod keylen])<br></code></pre></td></tr></table></figure><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/rc4_s_t.png" alt="rc4_s_t"><figcaption aria-hidden="true">rc4_s_t</figcaption></figure><h4 id="初始化置换-s">初始化置换 S</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">j = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span> to <span class="hljs-number">255</span> <span class="hljs-keyword">do</span> <br>	j = (j + S[i] + T[i]) (mod <span class="hljs-number">256</span>) <br>	swap (S[i], S[j])<br></code></pre></td></tr></table></figure><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/rc4_s.png" alt="rc4_s"><figcaption aria-hidden="true">rc4_s</figcaption></figure><h4 id="生成流密钥">生成流密钥</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">i = j = <span class="hljs-number">0</span> <br><span class="hljs-keyword">for</span> each message byte b<br>	i = (i + <span class="hljs-number">1</span>) (mod <span class="hljs-number">256</span>)<br>	j = (j + S[i]) (mod <span class="hljs-number">256</span>)<br>	swap(S[i], S[j])<br>	t = (S[i] + S[j]) (mod <span class="hljs-number">256</span>) <br>	print S[t]<br></code></pre></td></tr></table></figure><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/rc4_key.png" alt="rc4_key"><figcaption aria-hidden="true">rc4_key</figcaption></figure><p>我们一般称前两部分为 KSA ，最后一部分是 PRGA。</p><h3 id="rust实现-2">Rust实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rc4</span> &#123;<br>    s: [<span class="hljs-type">u32</span>; <span class="hljs-number">256</span>],<br>    key: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rc4</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(key: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">key</span> = key;<br>        <span class="hljs-keyword">if</span> key.<span class="hljs-title function_ invoke__">len</span>() == <span class="hljs-number">0</span> &#123;<br>            key = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">rc4</span> = <span class="hljs-keyword">Self</span> &#123;<br>            s: [<span class="hljs-number">0u32</span>; <span class="hljs-number">256</span>],<br>            key,<br>        &#125;;<br>        rc4.<span class="hljs-title function_ invoke__">init</span>();<br>        rc4<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">k</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0u32</span>; <span class="hljs-number">256</span>];<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">256</span> &#123;<br>            <span class="hljs-keyword">self</span>.s[i] = i <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br>            k[i] = <span class="hljs-keyword">self</span>.key[i % <span class="hljs-keyword">self</span>.key.<span class="hljs-title function_ invoke__">len</span>()] <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">j</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">256</span> &#123;<br>            j = (j + <span class="hljs-keyword">self</span>.s[i] + k[i]) % <span class="hljs-number">256</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">tmp</span> = <span class="hljs-keyword">self</span>.s[i];<br>            <span class="hljs-keyword">self</span>.s[i] = <span class="hljs-keyword">self</span>.s[j <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>];<br>            <span class="hljs-keyword">self</span>.s[j <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] = tmp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">crypt</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, data: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>]) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">j</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">t</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-keyword">self</span>.s.<span class="hljs-title function_ invoke__">clone</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">k</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..data.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>            j = (j + s[i]) % <span class="hljs-number">256</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">tmp</span> = s[i];<br>            s[i] = s[j <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>];<br>            s[j <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] = tmp;<br>            t = (s[i] + s[j <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>]) % <span class="hljs-number">256</span>;<br>            data[k] ^= s[t <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>] <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/rc4.png" alt="rc4"><figcaption aria-hidden="true">rc4</figcaption></figure><h1 id="块加密">块加密</h1><h2 id="概述">概述</h2><p>所谓块加密就是每次加密一块明文，常见的加密算法有</p><ul><li>IDEA 加密</li><li>DES 加密</li><li>AES 加密</li></ul><p>块加密也是对称加密。</p><p>其实，我们也可以把块加密理解一种特殊的替代密码，但是其每次替代的是一大块。而正是由于一大块，明文空间巨大，而且对于不同的密钥，我们无法做一个表进行对应相应的密文，因此必须得有 <strong>复杂</strong> 的加解密算法来加解密明密文。</p><p>而与此同时，明文往往可能很长也可能很短，因此在块加密时往往需要两个辅助</p><ul><li>padding，即 padding 到指定分组长度</li><li>分组加密模式，即明文分组加密的方式。</li></ul><h2 id="填充规则">填充规则</h2><p>正如我们之前所说，在分组加密中，明文的长度往往并不满足要求，需要进行 padding，而如何 padding 目前也已经有了不少的规定。</p><p>常见的 <a target="_blank" rel="noopener" href="https://www.di-mgt.com.au/cryptopad.html">填充规则</a> 如下。<strong>需要注意的是，即使消息的长度是块大小的整数倍，仍然需要填充。</strong></p><p>一般来说，如果在解密之后发现 Padding 不正确，则往往会抛出异常。我们也因此可以知道 Paddig 是否正确。</p><h3 id="pad-with-bytes-all-of-the-same-value-as-the-number-of-padding-bytes-pkcs5-padding">Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding)</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">DES INPUT BLOCK  = f  o  r  _  _  _  _  _<br>(IN HEX)           66 6F 72 05 05 05 05 05<br>KEY              = 01 23 45 67 89 AB CD EF<br>DES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40<br></code></pre></td></tr></table></figure><h3 id="pad-with-0x80-followed-by-zero-bytes-oneandzeroes-padding">Pad with 0x80 followed by zero bytes (OneAndZeroes Padding)</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">DES INPUT BLOCK  = f  o  r  _  _  _  _  _<br>(IN HEX)           66 6F 72 80 00 00 00 00<br>KEY              = 01 23 45 67 89 AB CD EF<br>DES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40<br></code></pre></td></tr></table></figure><p>这里其实就是和 md5 和 sha1 的 padding 差不多。</p><h3 id="pad-with-zeroes-except-make-the-last-byte-equal-to-the-number-of-padding-bytes">Pad with zeroes except make the last byte equal to the number of padding bytes</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">DES INPUT BLOCK  = f  o  r  _  _  _  _  _<br>(IN HEX)           66 6f 72 00 00 00 00 05<br>KEY              = 01 23 45 67 89 AB CD EF<br>DES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8<br></code></pre></td></tr></table></figure><h3 id="pad-with-zero-null-characters">Pad with zero (null) characters</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">DES INPUT BLOCK  = f  o  r  _  _  _  _  _<br>(IN HEX)           66 6f 72 00 00 00 00 00<br>KEY              = 01 23 45 67 89 AB CD EF<br>DES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75<br></code></pre></td></tr></table></figure><h3 id="pad-with-spaces">Pad with spaces</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">DES INPUT BLOCK  = f  o  r  _  _  _  _  _<br>(IN HEX)           66 6f 72 20 20 20 20 20<br>KEY              = 01 23 45 67 89 AB CD EF<br>DES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25<br></code></pre></td></tr></table></figure><h2 id="工作模式">工作模式</h2><p>分组密码的工作模式是：根据不同的数据格式和安全性要求, 以一个具体的分组密码算法为基础构造一个分组密码系统的方法。分组密码的工作模式应当力求简单, 有效和易于实现，需要采用适当的工作模式来隐蔽明文的统计特性、数据的格式等，降低删除、重放、插入和伪造成功的机会。</p><p>分组密码的主要工作模式：</p><ol type="1"><li>电码本(ECB)模式</li><li>密码分组链接(CBC)模式</li><li>密码反馈(CFB)模式</li><li>输出反馈(OFB)模式</li><li>计数器(CTR)模式</li></ol><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/工作模式比较.png" alt="分组密码的工作模式比较"><figcaption aria-hidden="true">分组密码的工作模式比较</figcaption></figure><h2 id="基本策略">基本策略</h2><p>在分组密码设计时，充分使用了 Shannon 提出的两大策略：混淆与扩散两大策略。</p><h3 id="混淆">混淆</h3><p>混淆，Confusion，将密文与密钥之间的统计关系变得尽可能复杂，使得攻击者即使获取了密文的一些统计特性，也无法推测密钥。一般使用复杂的非线性变换可以得到很好的混淆效果，常见的方法如下</p><ul><li>S 盒</li><li>乘法</li></ul><h3 id="扩散">扩散</h3><p>扩散，Diffusion，使得明文中的每一位影响密文中的许多位。常见的方法有</p><ul><li>线性变换</li><li>置换</li><li>移位，循环移位</li></ul><h2 id="常见加解密结构">常见加解密结构</h2><p>目前块加密中主要使用的是结构是</p><ul><li>迭代结构，这是因为迭代结构便于设计与实现，同时方便安全性评估。</li></ul><h3 id="迭代结构">迭代结构</h3><h4 id="概述-1">概述</h4><p>迭代结构基本如下，一般包括三个部分</p><ul><li>密钥置换</li><li>轮加密函数</li><li>轮解密函数</li></ul><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/iterated_cipher.png" alt="iterated_cipher"><figcaption aria-hidden="true">iterated_cipher</figcaption></figure><h4 id="轮函数">轮函数</h4><p>目前来说，轮函数主要有主要有以下设计方法</p><ul><li>Feistel Network，由 Horst Feistel 发明，DES 设计者之一。<ul><li>DES</li></ul></li><li>Substitution-Permutation Network(SPN)<ul><li>AES</li></ul></li><li>其他方案</li></ul><h4 id="密钥扩展">密钥扩展</h4><p>目前，密钥扩展的方法有很多，没有见到什么完美的密钥扩展方法，基本原则是使得密钥的每一个比特尽可能影响多轮的轮密钥。</p><h2 id="des">DES</h2><h3 id="基本介绍-1">基本介绍</h3><p>Data Encryption Standard(DES)，数据加密标准，是典型的块加密，其基本信息如下</p><ul><li>输入 64 位。</li><li>输出 64 位。</li><li>密钥 64 位，使用 64 位密钥中的 56 位，剩余的 8 位要么丢弃，要么作为奇偶校验位。</li><li>Feistel 迭代结构<ul><li>明文经过 16 轮迭代得到密文。</li><li>密文经过类似的 16 轮迭代得到明文。</li></ul></li></ul><h3 id="基本流程-1">基本流程</h3><p>给出一张简单的 DES 流程图。</p><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/des.gif" alt="des"><figcaption aria-hidden="true">des</figcaption></figure><h4 id="加密">加密</h4><p>我们可以考虑一下每一轮的加密过程</p><p><span class="math display">\[L_{i+1}=R_i\]</span></p><p><span class="math display">\[R_{i+1}=L_i\oplus F(R_i,K_i)\]</span></p><p>那么在最后的 Permutation 之前，对应的密文为<span class="math inline">\((R_{n+1},L_{n+1})\)</span>。</p><h4 id="解密">解密</h4><p>那么解密如何解密呢？首先我们可以把密文先进行逆置换，那么就可以得到最后一轮的输出。我们这时考虑每一轮</p><p><span class="math display">\[R_i=L_{i+1}\]</span></p><p><span class="math display">\[L_i=R_{i+1}\oplus F(L_{i+1},K_i)\]</span></p><p>因此，<span class="math inline">\((L_0,R_0)\)</span> 就是加密时第一次置换后的明文。我们只需要再执行逆置换就可以获得明文了。</p><p>可以看出，DES 加解密使用同一套逻辑，只是密钥使用的顺序不一致。</p><h3 id="核心部件">核心部件</h3><p>DES 中的核心部件主要包括（这里只给出加密过程的）</p><ul><li>初始置换</li><li>F 函数<ul><li>E 扩展函数</li><li>S 盒，设计标准未给出。</li><li>P 置换</li></ul></li><li>最后置换</li></ul><p>其中 F 函数如下</p><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/f-function.png" alt="f-function"><figcaption aria-hidden="true">f-function</figcaption></figure><p>如果对 DES 更加感兴趣，可以进行更加仔细地研究。欢迎提供 PR。</p><h3 id="衍生">衍生</h3><p>在 DES 的基础上，衍生了以下两种加密方式</p><ul><li>双重 DES</li><li>三种 DES</li></ul><h4 id="双重-des">双重 DES</h4><p>双重 DES 使用两个密钥，长度为 112 比特。加密方式如下</p><p><span class="math display">\[C=E_{k2}(E_{k1}(P))\]</span></p><p>但是双重 DES 不能抵抗中间相遇攻击，我们可以构造如下两个集合</p><p><span class="math display">\[I={E_{k1}(P)}\]</span></p><p><span class="math display">\[J=D_{k2}(C)\]</span></p><p>即分别枚举 K1 和 K2 分别对 P 进行加密和对 C 进行解密。</p><p>在我们对 P 进行加密完毕后，可以对加密结果进行排序，这样的复杂度为<span class="math inline">\(2^nlog(2^n)=O(n2^n)\)</span></p><p>当我们对 C 进行解密时，可以每解密一个，就去对应的表中查询。</p><p>总的复杂度为还是<span class="math inline">\(O(n2^n)\)</span>。</p><h4 id="三重-des">三重 DES</h4><p>三重 DES 的加解密方式如下</p><p><span class="math display">\[C=E_{k3}(D_{k2}(E_{k1}(P)))\]</span></p><p><span class="math display">\[P=D_{k1}(E_{k2}(D_{k3}(C)))\]</span></p><p>在选择密钥时，可以有两种方法</p><ul><li>3 个不同的密钥，k1，k2，k3 互相独立，一共 168 比特。</li><li>2 个不同的密钥，k1 与 k2 独立，k3=k1，112 比特。</li></ul><h3 id="攻击方法">攻击方法</h3><ul><li>差分攻击</li><li>线性攻击</li></ul><h2 id="aes">AES</h2><h3 id="基本介绍-2">基本介绍</h3><p>Advanced Encryption Standard（AES），高级加密标准，是典型的块加密，被设计来取代 DES，由 Joan Daemen 和 Vincent Rijmen 所设计。其基本信息如下</p><ul><li>输入：128 比特。</li><li>输出：128 比特。</li><li>SPN 网络结构。</li></ul><p>其迭代轮数与密钥长度有关系，如下</p><table><thead><tr><th style="text-align:center">密钥长度（比特）</th><th style="text-align:center">迭代轮数</th></tr></thead><tbody><tr><td style="text-align:center">128</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">192</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">256</td><td style="text-align:center">14</td></tr></tbody></table><h3 id="基本流程-2">基本流程</h3><h4 id="基本概念">基本概念</h4><p>在 AES 加解密过程中，每一块都是 128 比特，所以我们这里明确一些基本概念。</p><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/aes_data_unit.png" alt="aes_data_unit"><figcaption aria-hidden="true">aes_data_unit</figcaption></figure><p>在 AES 中，块与 State 之间的转换过程如下</p><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/aes_block2state.png" alt="aes_block2state"><figcaption aria-hidden="true">aes_block2state</figcaption></figure><p>所以，可以看出，每一个 block 中的字节是按照列排列进入到状态数组的。</p><p>而对于明文来说，一般我们会选择使用其十六进制进行编码。</p><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/aes_plain2state.png" alt="aes_plain2state"><figcaption aria-hidden="true">aes_plain2state</figcaption></figure><h4 id="加解密过程">加解密过程</h4><p>这里给个看雪上比较好的 <a target="_blank" rel="noopener" href="http://bbs.pediy.com/thread-90722.htm">图例</a> ，以便于介绍基本的流程，每一轮主要包括</p><ul><li>轮密钥加，AddRoundKey</li><li>字节替换，SubBytes</li><li>行移位，ShiftRows</li><li>列混淆，MixColumns</li></ul><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/aes_details.jpg" alt="aes_details"><figcaption aria-hidden="true">aes_details</figcaption></figure><p>上面的列混淆的矩阵乘法等号左边的列向量应该在右边。</p><p>这里再给一张其加解密的全图，其解密算法的正确性很显然。</p><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/aes_enc_dec.png" alt="aes_enc_dec"><figcaption aria-hidden="true">aes_enc_dec</figcaption></figure><p>我们这里重点关注一下以下。</p><h5 id="字节替换">字节替换</h5><p>在字节替换的背后，其实是有对应的数学规则来定义对应的替换表的，如下</p><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/aes_subbytes.png" alt="aes_subbytes"><figcaption aria-hidden="true">aes_subbytes</figcaption></figure><p>这里的运算均定义在 <span class="math inline">\(GF(2^8)\)</span> 内。</p><h5 id="列混淆">列混淆</h5><p>这里的运算也是定义在 <span class="math inline">\(GF(2^8)\)</span> 上，使用的模多项式为 <span class="math inline">\(x^8+x^4+x^3+1\)</span>。</p><h5 id="密钥扩展-1">密钥扩展</h5><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/aes_key_expansion.png" alt="aes_key_expansion"><figcaption aria-hidden="true">aes_key_expansion</figcaption></figure><h3 id="等价解密算法">等价解密算法</h3><p>简单分析一下，我们可以发现</p><ul><li>交换逆向行移位和逆向字节代替并不影响结果。</li><li>交换轮密钥加和逆向列混淆并不影响结果，关键在于<ul><li>首先可以把异或看成域上的多项式加法</li><li>然后多项式中乘法对加法具有分配率。</li></ul></li></ul><h3 id="攻击方法-1">攻击方法</h3><ul><li>积分攻击</li></ul><h1 id="非对称加密">非对称加密</h1><h2 id="介绍-2">介绍</h2><p>在非对称密码中，加密者与解密者所使用的密钥并不一样，典型的有 RSA 加密，背包加密，椭圆曲线加密。</p><h2 id="rsa">RSA</h2><p>RSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。</p><p>RSA 算法的可靠性由极大整数因数分解的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2020 年为止，还没有任何可靠的攻击 RSA 算法的方式。</p><h3 id="基本原理">基本原理</h3><h4 id="公钥与私钥的产生">公钥与私钥的产生</h4><ol type="1"><li>随机选择两个不同大质数 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span>，计算 <span class="math inline">\(N = p \times q\)</span></li><li>根据欧拉函数，求得 <span class="math inline">\(\varphi (N)=\varphi (p)\varphi (q)=(p-1)(q-1)\)</span></li><li>选择一个小于 <span class="math inline">\(\varphi (N)\)</span> 的整数 <span class="math inline">\(e\)</span>，使 <span class="math inline">\(e\)</span> 和 <span class="math inline">\(\varphi (N)\)</span> 互质。并求得 <span class="math inline">\(e\)</span> 关于 <span class="math inline">\(\varphi (N)\)</span> 的模反元素，命名为 <span class="math inline">\(d\)</span>，有 <span class="math inline">\(ed\equiv 1 \pmod {\varphi (N)}\)</span></li><li>将 <span class="math inline">\(p​\)</span> 和 <span class="math inline">\(q​\)</span> 的记录销毁</li></ol><p>此时，<span class="math inline">\((N,e)\)</span> 是公钥，<span class="math inline">\((N,d)\)</span> 是私钥。</p><h4 id="消息加密">消息加密</h4><p>首先需要将消息 以一个双方约定好的格式转化为一个小于 <span class="math inline">\(N\)</span>，且与 <span class="math inline">\(N\)</span> 互质的整数 <span class="math inline">\(m\)</span>。如果消息太长，可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密：</p><p><span class="math display">\[ m^{e}\equiv c\pmod N \]</span></p><h4 id="消息解密">消息解密</h4><p>利用密钥 <span class="math inline">\(d​\)</span> 进行解密。</p><p><span class="math display">\[ c^{d}\equiv m\pmod N \]</span></p><h4 id="正确性证明">正确性证明</h4><p>即我们要证<span class="math inline">\(m^{ed} \equiv m \bmod N\)</span>，已知<span class="math inline">\(ed \equiv 1 \bmod \phi(N)\)</span>，那么 <span class="math inline">\(ed=k\phi(N)+1\)</span>，即需要证明</p><p><span class="math display">\[ m^{k\phi(N)+1} \equiv m \bmod N \]</span></p><p>这里我们分两种情况证明</p><p>第一种情况 <span class="math inline">\(gcd(m,N)=1​\)</span>，那么 <span class="math inline">\(m^{\phi(N)} \equiv 1 \bmod N​\)</span>，因此原式成立。</p><p>第二种情况 <span class="math inline">\(gcd(m,N)\neq 1\)</span>，那么 <span class="math inline">\(m\)</span> 必然是 <span class="math inline">\(p\)</span> 或者 <span class="math inline">\(q\)</span> 的倍数，并且 <span class="math inline">\(n=m\)</span> 小于 <span class="math inline">\(N\)</span>。我们假设</p><p><span class="math display">\[ m=xp \]</span></p><p>那么 <span class="math inline">\(x\)</span> 必然小于 <span class="math inline">\(q\)</span>，又由于 <span class="math inline">\(q\)</span> 是素数。那么</p><p><span class="math display">\[ m^{\phi(q)} \equiv 1 \bmod q \]</span></p><p>进而</p><p><span class="math display">\[ m^{k\phi(N)}=m^{k(p-1)(q-1)}=(m^{\phi(q)})^{k(p-1)} \equiv 1 \bmod q \]</span></p><p>那么</p><p><span class="math display">\[ m^{k\phi(N)+1}=m+uqm \]</span></p><p>进而</p><p><span class="math display">\[ m^{k\phi(N)+1}=m+uqxp=m+uxN \]</span></p><p>所以原式成立。</p><h3 id="样例-2">样例</h3><h4 id="例1">例1</h4><h5 id="计算公钥和私钥">计算公钥和私钥</h5><ol type="1"><li><p>p = 13 , q = 5</p><ul><li>N = pq = 65</li><li>r = (p-1)(q-1) = (13-1)(5-1) = 48</li></ul></li><li><p>计算模反元素 r=48，选择e=5，得到二元一次方程：5d-48k=1 , 获得一组解：d=29，k=3</p></li><li><p>因此，公钥是 (N, e) = (65, 5)，私钥是 (N, d) = (65, 29)。</p></li></ol><h5 id="加密信息">加密信息</h5><ol type="1"><li><p>明文：m=3</p></li><li><p>计算: $ c ^{5} $</p></li><li><p>因此：3被加密为48</p></li></ol><h5 id="解密信息">解密信息</h5><ol type="1"><li><p>密文：c=48</p></li><li><p>计算：$ n ^{29} $</p></li><li><p>因此：48被解密为3</p></li></ol><h4 id="例2">例2</h4><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/rsa.png" alt="rsa-1"><figcaption aria-hidden="true">rsa-1</figcaption></figure><h1 id="密码协议">密码协议</h1><h2 id="diffie-hellman-密钥交换">Diffie-Hellman 密钥交换</h2><ul><li>密钥交换是实现安全通信的基础<ul><li>商用加密算法AES和DES需要在安全通信之前，实现通信双方的密钥共享。</li></ul></li><li>密钥交换的方法：<ul><li>基于RSA的密钥交换；</li><li>基于KDC技术 (Key Distributed Center，密钥分发中心)；</li><li><strong>Diffie-Hellman密钥交换</strong>（简称：DH算法）；</li><li>基于物理层的密钥交换。</li></ul></li></ul><p>DH算法是不安全信道下实现安全密钥共享的一种方法，由 W. Diffie 和 M.Hellman 在1976年提出的第一个公开的<strong>公钥密码算法</strong>。</p><figure><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/DH-1.png" alt="DH-1"><figcaption aria-hidden="true">DH-1</figcaption></figure><h2 id="dh协议案例">DH协议案例</h2><p><img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/DH-3.png" alt="DH-3"> <img lazyload src="/img/loading.gif" data-src="https://raw.githubusercontent.com/Mundi-Xu/picture_resource/master/picture/基于RUST的密码学系统/DH-2.png" alt="DH-2"></p><h1 id="参考">参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://github.com/Mundi-Xu/cipher_web_rocket" class="uri">https://github.com/Mundi-Xu/cipher_web_rocket</a> <a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://github.com/yuankeyang/python/blob/master/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B.pdf">深入浅出密码学——常用加密技术原理与应用</a> <a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Security-Research/" class="category-chain-item">Security Research</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Cryptography/" class="print-no-link">#Cryptography</a> <a href="/tags/Symmetric-Cryptography/" class="print-no-link">#Symmetric Cryptography</a> <a href="/tags/Asymmetric-Cryptography/" class="print-no-link">#Asymmetric Cryptography</a> <a href="/tags/rust/" class="print-no-link">#rust</a></div></div><div class="license-box my-3"><div class="license-title"><div>密码学初探-基于RUST的密码系统与算法简析</div><div>https://mundi-xu.github.io/2020/12/27/A-Brief-Analysis-of-Cryptographic-Algorithm-RUST/</div></div><div class="license-meta"><div class="license-meta-item"><div>Author</div><div>煊宇</div></div><div class="license-meta-item license-meta-date"><div>Posted on</div><div>December 27, 2020</div></div><div class="license-meta-item"><div>Licensed under</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/" rel="external nofollow noreferrer"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-cc-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/" rel="external nofollow noreferrer"><span class="hint--top hint--rounded" aria-label="NC - Non-commercial"><i class="iconfont icon-cc-nc"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2020/12/28/Research-on-Ransomware-Structure-and-Encryption-Mode/" title="勒索软件结构与加密模式研究"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">勒索软件结构与加密模式研究</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/2020/07/01/Blockchain-based-security-log-system/" title="基于区块链的安全日志系统"><span class="hidden-mobile">基于区块链的安全日志系统</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="giscus" class="giscus"></div><script type="text/javascript">Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"Mundi-Xu/mundi-xu.github.io","repo-id":"MDEwOlJlcG9zaXRvcnkxNTQ1OTg4Mjg=","category":"Announcements","category-id":"DIC_kwDOCTb9rM4CeUGi","theme-light":"light","theme-dark":"dark","mapping":"title","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN","strict":0};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>Table of Contents</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="mailto:mundi.xu@gmail.com?subject=Interested+In+Your+Blog" rel="external nofollow noreferrer" target="_blank"><span>Contact me</span></a> <i class="iconfont icon-love"></i> <a href="mailto:mundi.xu@gmail.com?subject=Interested+In+Your+Blog" rel="external nofollow noreferrer" target="_blank"><span>mundi.xu@gmail.com</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">Views: <span id="busuanzi_value_site_pv"></span> </span><span id="busuanzi_container_site_uv" style="display:none">Visitors: <span id="busuanzi_value_site_uv"></span></span></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.2/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/typed.js/2.1.0/typed.umd.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>var relativeDate=function(){var t,e,a,d,i=document.getElementById("updated-time");i&&(e=/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/,(a=(t=i.textContent).match(e))&&(d=dayjs(a[0]).fromNow(),i.textContent=t.replace(e,d)),i.style.display="")};Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/dayjs.min.js",function(){Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/plugin/relativeTime.min.js",function(){dayjs.extend(dayjs_plugin_relativeTime),"en".startsWith("en")?relativeDate():Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/locale/en.min.js",function(){dayjs.locale("en"),relativeDate()})})})</script><script>Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.36.4/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://cdnjs.cloudflare.com/ajax/libs/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/DynamicLine.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>